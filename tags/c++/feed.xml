<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>C&#43;&#43; on Adro的作死笔记</title>
    <link>http://shamaoxiaogui.github.io/tags/c&#43;&#43;/</link>
    <description>Recent content in C&#43;&#43; on Adro的作死笔记</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <lastBuildDate>Fri, 29 Jul 2016 09:05:34 +0800</lastBuildDate>
    <atom:link href="http://shamaoxiaogui.github.io/tags/c&#43;&#43;/feed/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>深入理解cpp对象模型 第六章笔记</title>
      <link>http://shamaoxiaogui.github.io/post/inside_cpp_object_model_ch6/</link>
      <pubDate>Fri, 29 Jul 2016 09:05:34 +0800</pubDate>
      
      <guid>http://shamaoxiaogui.github.io/post/inside_cpp_object_model_ch6/</guid>
      <description>

&lt;h2 id=&#34;全局变量的初始化问题&#34;&gt;全局变量的初始化问题。&lt;/h2&gt;

&lt;p&gt;考虑在如下代码中，全局和静态变量都放在哪个段中，初始化顺序又如何&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;string&amp;gt;
using namespace std;
class nonPOD{
public:
    nonPOD(const string&amp;amp; s=&amp;quot;default&amp;quot;):str(s){cout&amp;lt;&amp;lt;str&amp;lt;&amp;lt;&amp;quot; nonPOD ctor&amp;quot;&amp;lt;&amp;lt;endl;}
    nonPOD(const nonPOD&amp;amp; t):n(t.n),str(t.str+&amp;quot;_copy&amp;quot;){cout&amp;lt;&amp;lt;str&amp;lt;&amp;lt;&amp;quot; copy ctor&amp;quot;&amp;lt;&amp;lt;endl;}
    virtual ~nonPOD(){cout&amp;lt;&amp;lt;str&amp;lt;&amp;lt;&amp;quot; nonPOD dctor&amp;quot;&amp;lt;&amp;lt;endl;}
    int getn(){return n;}
private:
    int n;
    string str;
};
struct POD{
    int i;
    char ch;
};

nonPOD np;
nonPOD np1(&amp;quot;hehe&amp;quot;);
nonPOD np2(np1);
POD p;
POD p1={1,&#39;c&#39;};
int gzn;    //bss
int gn=4;   //data

int main(){
    cout&amp;lt;&amp;lt;&amp;quot;main start&amp;quot;&amp;lt;&amp;lt;endl;
    static int szn;
    static int sn=5;
    cout&amp;lt;&amp;lt;&amp;quot;gzn: &amp;quot;&amp;lt;&amp;lt;gzn&amp;lt;&amp;lt;&amp;quot; gn: &amp;quot;&amp;lt;&amp;lt;gn&amp;lt;&amp;lt;&amp;quot; szn: &amp;quot;&amp;lt;&amp;lt;szn&amp;lt;&amp;lt;&amp;quot; sn: &amp;quot;&amp;lt;&amp;lt;sn&amp;lt;&amp;lt;endl;
    static nonPOD snp;
    static nonPOD snp1(&amp;quot;static hehe&amp;quot;);
    static POD sp;
    static POD sp1={1,&#39;c&#39;};
    cout&amp;lt;&amp;lt;&amp;quot;np.n: &amp;quot;&amp;lt;&amp;lt;np.getn()&amp;lt;&amp;lt;endl;
    cout&amp;lt;&amp;lt;&amp;quot;np1.n: &amp;quot;&amp;lt;&amp;lt;np1.getn()&amp;lt;&amp;lt;endl;
    cout&amp;lt;&amp;lt;&amp;quot;np2.n: &amp;quot;&amp;lt;&amp;lt;np2.getn()&amp;lt;&amp;lt;endl;
    cout&amp;lt;&amp;lt;&amp;quot;snp.n: &amp;quot;&amp;lt;&amp;lt;snp.getn()&amp;lt;&amp;lt;endl;
    cout&amp;lt;&amp;lt;&amp;quot;snp1.n: &amp;quot;&amp;lt;&amp;lt;snp1.getn()&amp;lt;&amp;lt;endl;
    cout&amp;lt;&amp;lt;&amp;quot;p.i: &amp;quot;&amp;lt;&amp;lt;p.i&amp;lt;&amp;lt;endl;
    cout&amp;lt;&amp;lt;&amp;quot;sp.i: &amp;quot;&amp;lt;&amp;lt;sp.i&amp;lt;&amp;lt;endl;
    cout&amp;lt;&amp;lt;&amp;quot;main stop&amp;quot;&amp;lt;&amp;lt;endl;
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ ./segment.out
default nonPOD ctor
hehe nonPOD ctor
hehe_copy copy ctor
main start
gzn: 0 gn: 4 szn: 0 sn: 5
default nonPOD ctor
static hehe nonPOD ctor
np.n: 0
np1.n: 0
np2.n: 0
snp.n: 0
snp1.n: 0
p.i: 0
sp.i: 0
main stop
static hehe nonPOD dctor
default nonPOD dctor
hehe_copy nonPOD dctor
hehe nonPOD dctor
default nonPOD dctor
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个信息量，呵呵。。。好了，我们来分析一下：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;全局变量的构造，一定是在main函数开始之前完成，而静态变量是从第一次定义它的时候才构建，这个是没有异议的。&lt;/li&gt;
&lt;li&gt;析构顺序，全局对象与静态对象算在一起，按与它们构建相反的顺序析构。
1.
但是构建的顺序，这里就有坑了。上面的代码是在同一个文件中，全局变量似乎确实是按照定义的顺序来构造的。但是考虑这样一种情况，有一部分全局变量分散在其它文件中（比如库），本文件使用extern声明它们，那这时候构造顺序是什么样子的？好吧，我没有去实验，而且各家的编译器标准也不太一样，但是可以认为，至少在03标准中，全局变量的构建顺序是不确定的，唯一确定的就是上面说的，在main之前能构造完。这样就会产生一个问题，一旦某个全局变量的构造依赖于另一个全局变量，不能保证另一个对象在本对象构造前已经构造好，这就会造成问题。所以很多人建议，要不不要在全局对象中引入依赖（不太可能），要不使用静态变量代替（或多或少也会有这种问题），或者将这些有依赖的全局对象之间的依赖关系，选一个特定的过程来构造它们，比如说构建静态变量的单例模式。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;高能预警分割线&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;回到开篇的问题，这些对象都放在哪个段？回忆一下c语言，“全局和静态初始化变量放在全局数据区，全局和静态未初始化变量放在BSS段”，好吧，其实不是这么简单的。首先来想一下，全局数据段是干嘛的。当我们使用unix下的exec系的调用时，操作系统加载可执行文件，从文件中读入DATA段，然后DATA段之间放入内存，也就是说是一种直接加载的模式。而BSS段，它不占用可执行文件的空间，因为系统加载这段时，只是读取大小然后在内存中开辟一段这个大小的内存，然后清零就好了。所以说所谓的“全局和静态未初始化变量”是有初始值的，其内存填0。
那我们通过nm工具来查看下符号表：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;...
000000010000318c d __ZZ4mainE2sn
00000001000032b8 b __ZZ4mainE2sp
0000000100003258 b __ZZ4mainE3snp
0000000100003190 d __ZZ4mainE3sp1
0000000100003250 b __ZZ4mainE3szn
0000000100003288 b __ZZ4mainE4snp1
...
0000000100000000 T __mh_execute_header
0000000100003188 D _gn
0000000100003248 S _gzn
0000000100000e00 T _main
00000001000031c8 S _np
00000001000031f0 S _np1
0000000100003218 S _np2
0000000100003240 S _p
0000000100003180 D _p1
                 U _strlen
                 U dyld_stub_binder
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里只贴一小部分分析。简单解释下符合，D代表DATA段，T代表TEXT段，U代表未在本文件定义，也就是外部符号，而S，手册上说的是“不在以上所有段中”，之前的man page中说的是未初始化数据段，用于small object，似乎和B代表的BSS段一样啊。在之前的代码中，我们能确定的就是gzn一定是在BSS段，gn一定是在DATA段，再观察符号表，发现gzn对应着S，所以我们就当S是BSS段好了。&lt;/p&gt;

&lt;p&gt;回到正题。全局和静态对象放在哪，首先我们不考虑POD，关注代码中的np＊和snp＊，发现不是S就是b，居然全都是BSS段。而POD类型，p和sp对应b或S放在BSS段，它们都是默认初始化的；而p1和sp1则都放在DATA段，是显示初始化的。&lt;/p&gt;

&lt;p&gt;好吧，跟普通内置类型不一样啊。实际上，所有的全局或者静态对象（包括内置变量）在初始化的过程中，标准定义了以下几个阶段：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;静态初始化阶段，这个阶段又细分为以下两个阶段：

&lt;ol&gt;
&lt;li&gt;零初始化阶段：系统为对象准备内存，清零&lt;/li&gt;
&lt;li&gt;常量初始化阶段：在清零的内存中加载可执行文件中已定义好的数据&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;动态初始化阶段：完成一些不能依靠简单的加载可执行文件就能做到的功能。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;我们一一举例。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;零初始化阶段，准备并清零内存，是不是很熟悉？BSS段么，所以BSS段中的对象就只执行静态初始化中的零初始化阶段，没有常量初始化阶段。&lt;/li&gt;
&lt;li&gt;常量初始化阶段。比如定义一个全局变量：&lt;code&gt;int x=5;&lt;/code&gt;，按照标准而言，系统会先在内存中为x清零一段sizeof(x)的内存（零初始化阶段），然后将可执行文件中的5加载到这个内存中（常量初始化）。蛋疼不？反正最后得加载内存，为啥还要清零？所以很多系统、编译器在这里跳过零初始化阶段，编译生成可执行文件时把这种可以直接加载到内存而不需要提前清零的全局或者静态变量放到DATA段里，系统就只需要一步常量初始化就OK了。&lt;/li&gt;
&lt;li&gt;动态初始化阶段，比如定义一个全局变量，其初始值不能在编译期决定&lt;code&gt;int x=getInt();&lt;/code&gt;，因为编译器不知道你这个getInt函数会返回什么值，它的值是在运行期动态决定的，这时候就需要动态初始化了。详细来讲，对于这个x，先清零内存（零初始化），再在main之前的startup代码中执行getInt来初始化它的值（动态初始化）。所以这个x也应该放到BSS中。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;好了，现在我们来看类。一个全局活着静态类，如果不是POD，那必须用其构造函数来初始化，所以这就决定了它们必然会经历动态初始化阶段，所以我们上面看到的np＊和snp＊都在BSS段中。这些类的初始化过程是：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;静态初始化（只执行零初始化阶段，清零内存） &amp;ndash;&amp;gt; 动态初始化（执行构造函数）&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;对可执行文件中段的占用也就是bss（内存数据占用）＋init（或者finit、ctor等构造函数占用）段&lt;/p&gt;

&lt;p&gt;而POD类则不一样。C++中POD类型是唯一可以进行静态初始化（特指常量初始化）的类型（这里不但指POD类，也指大多数标量类型，具体POD类型包含哪些，参照&lt;a href=&#34;https://zh.wikipedia.org/wiki/POD_(程序设计)&#34;&gt;wiki&lt;/a&gt;）。也就是说POD可以进行内存加载直接初始化。所以上面的代码中p1和sp1都是直接放在DATA段中的，初始化过程只有静态初始化中的常量初始化。而p和sp则放到BSS段中，进行的是静态初始化中的零初始化过程。二者都不涉及（由构造函数导致的）动态初始化。（因为其它运行时因素，比如用函数返回值来初始化它们，仍然会引发动态初始化）总体上而言，我们将POD类与内置标量类型同样看待会比较好理解。&lt;/p&gt;

&lt;p&gt;那么现在，我们就可以解释上面程序的输出了。在输出中，那些默认初始化的非POD类的int成员都是0，因为它们放在bss段中，内存被清0，而构造函数又没有修改它们，所以就是0。&lt;/p&gt;

&lt;p&gt;最后，关于初始化，静态初始化的优势在于快，11标准的constexpr就是优化初始化的大杀器，具体的去google吧。奥，还有，c语言中我们有时这样写代码不会出错：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;int i;
int i;
int i=6;
//...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这是因为c支持“临时性定义”的概念，链接器会把这些实例给折叠，只留下一个实例，国内某些万恶的培训机构说的这是声明不是定义，呵呵。。c++是不支持“临时性定义的概念”的，这样写只会报错。还有，对于静态对象，如果第一构建出错（抛异常，但是捕捉到，没有终止程序），那么下一次程序运行到这个位置还会再次尝试构建。&lt;/p&gt;

&lt;p&gt;我的表达能力有限，如果想看权威的文献，异步&lt;a href=&#34;http://en.cppreference.com/w/cpp/language/initialization&#34;&gt;这里&lt;/a&gt;;&lt;/p&gt;

&lt;p&gt;开完小差的分割线&lt;/p&gt;

&lt;hr /&gt;

&lt;ol&gt;
&lt;li&gt;关于new操作符，实际包括两步操作，第一步是分配空间，第二部构造。如果请求分配空间为0，new会分配1字节的空间，因为标准要求每次new的地址不同。&lt;/li&gt;
&lt;li&gt;关于delete，该用&lt;code&gt;delete []&lt;/code&gt;的地方不要用&lt;code&gt;delete&lt;/code&gt;，反过来也一样，因为其行为是未定义的，会根据编译器的不同而变，还记得有些公司的面试题里非要说delete一个内置变量的数组不会有问题，因为它只是不调用析构函数而言，扯蛋，你敢在你的产品里这样写么，就tm会出些刁钻的题难为学生，还误导人家。&lt;a href=&#34;http://stackoverflow.com/questions/1553382/is-delete-equal-to-delete&#34;&gt;这篇讨论&lt;/a&gt;就说的很好。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;delete[]&lt;/code&gt;一个数组时注意，不要把一个装有派生类的数组传给一个基类指针，然后delete[]，因为它会根据传入的指针判断每个数组成员的大小（也就是每个内存单元的大小）以及应该调用的析构函数，这样一定会出错（一方面调错析构函数，另一方面释放的内存大小不对）&lt;/li&gt;
&lt;li&gt;placement new operator，不支持多态，简单的把它当成对给定大小内存上的操作，注意内存的分配与回收，它本身是不分配内存的，而placement delete operator也是不回收内存的，二者配合可以节省内存加快构造速度，但是也增加了内存管理的复杂性。&lt;/li&gt;

&lt;li&gt;&lt;p&gt;如今大部分的编译器对于如下的表达式是不会生成临时对象的：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;T c=a+b;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;基本上都会用NRV优化为对c的拷贝构造函数的调用。但是下面的式子就不行了，会产生临时对象：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;c=a+b;
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;临时对象的声明周期：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;临时对象只有在完整表达式的最后一个步骤后才销毁&lt;/li&gt;
&lt;li&gt;如果临时对象是用来初始化另一个对象的，应在其初始化完成后才销毁&lt;/li&gt;
&lt;li&gt;如果临时对象被绑定给一个引用，则其生命周期持续到该引用的生命周期结束&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>深入理解cpp对象模型 第五章笔记</title>
      <link>http://shamaoxiaogui.github.io/post/inside_cpp_object_model_ch5/</link>
      <pubDate>Thu, 28 Jul 2016 09:59:16 +0800</pubDate>
      
      <guid>http://shamaoxiaogui.github.io/post/inside_cpp_object_model_ch5/</guid>
      <description>&lt;ol&gt;
&lt;li&gt;&lt;p&gt;对于以下代码：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;iostream&amp;gt;
struct abase{
    virtual ~abase()=0;     //Oops, pure virtual dctor must be defined, or there would be a link error
    virtual void func()=0;
    virtual void func1()=0;
protected:
    abase(char c=0):_ch(c){}
    char _ch;
};
abase::~abase(){std::cout&amp;lt;&amp;lt;&amp;quot;abase dctor&amp;quot;&amp;lt;&amp;lt;std::endl;}
abase::func(){}
struct derivied:public abase{
    void func(){}
    void func1(){}
    void func3(){abase::func();}
};
int main(){
    derivied d;
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;纯虚函数可以被定义，但是只能用于静态调用，所以说是否去定义实现一个纯虚函数对用户而言可选。但是析构函数例外。一个抽象类，如果定义了一个纯虚析构函数，就必须定义实现它，因为编译器会对其子类的析构函数进行扩展，如果定义在抽象类声明一个纯虚析构函数而不实现它，会产生链接错误。最好是将析构函数定义为虚函数而不是纯虚函数。&lt;/li&gt;
&lt;li&gt;既然抽象基类中含有数据成员，我们就应该为其提供一个初始化机制，以允许派生类能初始化它&lt;/li&gt;
&lt;li&gt;对于类中那些只操作该类的成员而不会影响后续派生类成员的接口，不要声明virtual&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;构造顺序：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;初始化virtual base class，从左到右（在继承列表中的顺序），由深到浅（在初始化列表中显示定义的就显式调用相应构造函数，否则调用默认构造函数）&lt;/li&gt;
&lt;li&gt;初始化base class，类似上一步&lt;/li&gt;
&lt;li&gt;设定虚表&lt;/li&gt;
&lt;li&gt;按声明顺序初始化成员，类似第一步的规则&lt;/li&gt;
&lt;li&gt;运行用户代码&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;对于用户提供的拷贝赋值运算符，注意&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;不要忘了考虑自赋值情况&lt;/li&gt;
&lt;li&gt;不要忘了处基类的拷贝&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;如果不提供显式的拷贝运算符，编译器会提供一个合成的，它会调用父类的拷贝运算。有时候没必要提供拷贝运算就不要提供，因为这种情况下编译器大都会使用trivial的拷贝运算，也就是位逐次拷贝，效率高。但是有时我们为了触发编译器的NRV优化，确实会提供拷贝构造函数。拷贝运算符对virtual base class的处理相当复杂，所以如果没有必要不要为virtual base class提供数据成员。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;析构顺序：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;运行用户代码&lt;/li&gt;
&lt;li&gt;析构成员，按声明的相反顺序&lt;/li&gt;
&lt;li&gt;设定虚表&lt;/li&gt;
&lt;li&gt;析构基类， 按声明的相反顺序&lt;/li&gt;
&lt;li&gt;析构虚基类，按构造的相反顺序&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;同样，对于析构函数，如果没有必要提供定义就不要提供，一旦编译器使用trivial的析构方法，效率会非常高，相当于只进行内存的释放。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>convariant return type and override</title>
      <link>http://shamaoxiaogui.github.io/post/covariant_and_override/</link>
      <pubDate>Wed, 27 Jul 2016 13:23:23 +0800</pubDate>
      
      <guid>http://shamaoxiaogui.github.io/post/covariant_and_override/</guid>
      <description>&lt;p&gt;我们都知道在类的继承体系中，想要override一个虚方法，要求新方法的函数返回类型以及函数签名同被覆盖的方法相同，也就是说，下面的代码：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;iostream&amp;gt;
using namespace std;
struct base{
    virtual int func(){cout&amp;lt;&amp;lt;&amp;quot;base func&amp;quot;&amp;lt;&amp;lt;endl;return 0;}
    virtual ~base(){}
};
struct derived:public base{
    virtual double func() override {cout&amp;lt;&amp;lt;&amp;quot;derivied func&amp;quot;&amp;lt;&amp;lt;endl;return 3.14;}
};
int main(){
    base *bp=new derived;
    bp-&amp;gt;func();
    delete bp;
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;是不能通过编译的。然而有一种例外情况，就是当新方法相对于被覆盖的方法而言，有convariant返回值类型的话，允许返回值类型不一致：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;/* Inheritance hierarchies

         NetServer
             |
             ^
            / \
NetServerTCP   NetServerSCTP


         NetClient
             |
             ^
            / \
NetClientTCP   NetClientSCTP

*/

class NetServer {
public:
    virtual NetClient* acceptConnection() = 0;
};

class NetServerTCP : public NetServer {
public:
    virtual NetClientTCP* acceptConnection();
};

class NetServerSCTP : public NetServer {
public:
    virtual NetClientSCTP* acceptConnection();
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样的override是允许的。c++标准中：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;The return type of an overriding function shall be either identical to the return type of the overridden function or covariant with the classes of the functions. If a function D::f overrides a function B::f, the return type of the functions are covariant if the satisfy the following criteria:&lt;/p&gt;

&lt;p&gt;both are pointers to classes or references to classes98)&lt;/p&gt;

&lt;p&gt;the class in the return type of B::f is the same class as the class in the return type of D::f or, is an unambiguous direct or indirect base class of the class in the return type of D::f and is accessible in D&lt;/p&gt;

&lt;p&gt;both pointers or references have the same cv-qualification and the class type in the return type of D::f has the same cv-qualification as or less cv-qualification than the class type in the return type of B::f.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;注意第三条关于cv-qualification，举个例子就是可以这样：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;struct base{
    const base* func(){return this;};
};
struct derivied: public base{
    derivied* func(){return this;}
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;但是不能反过来。&lt;/p&gt;

&lt;p&gt;总结一下，covariant返回值的情况简单来说就是如果在代码的某个位置可以用D代替B（D派生自B），那么就可以使用返回值为D的指针或引用的同签名函数override B中的虚函数。&lt;/p&gt;

&lt;p&gt;最后，记住const限定符修饰的方法与无const限定符修饰的是不同的函数，不会互相override，只会够成重载（overload）关系。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>const类和default constructor</title>
      <link>http://shamaoxiaogui.github.io/post/const_and_default_ctor/</link>
      <pubDate>Wed, 27 Jul 2016 09:33:07 +0800</pubDate>
      
      <guid>http://shamaoxiaogui.github.io/post/const_and_default_ctor/</guid>
      <description>&lt;p&gt;今天实验程序的时候，出现这样一个问题：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;struct statictest{
    // virtual void func(){}
    // virtual ~statictest(){}
private:
    int n;
};
int main(){
     const statictest st;
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ make
g++ -std=c++11 -Wall static.cpp -o static.out
static.cpp:14:23: error: default initialization of an object of const type
      &#39;const statictest&#39; without a user-provided default constructor
     const statictest st;
                      ^
static.cpp:14:25: note: add an explicit initializer to initialize &#39;st&#39;
     const statictest st;
                        ^
                        {}
static.cpp:10:9: warning: private field &#39;n&#39; is not used [-Wunused-private-field]
    int n;
        ^
1 warning and 1 error generated.
make: *** [static] Error 1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;const类不能使用编译器提供的默认初始化？
去stackoverflow查了一下，发现标准上说：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;If a program calls for the default initialization of an object of a const-qualified type T, T shall be a class type with a user-provided default constructor.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;大写的囧，让我来猜测下标准的意图。&lt;/p&gt;

&lt;p&gt;当我们写程序，写一个const变量时，其值是在定义时初始化后不能更改的，所以对类而言，定义一个const类又使用了默认初始化，那我们就必须告诉编译器我们希望默认初始化给这个类以初值，因为以后也不能给它赋值。所以需要一个用户定义的默认初始化函数。
囧囧的是，有大神提出了这种玩法：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;struct statictest{
    statictest();
    // virtual void func(){}
    // virtual ~statictest(){}
private:
    int n;
};
inline statictest::statictest()=default;
int main(){
     const statictest st;
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;是的，可以编译通过，因为标准说：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&amp;hellip; A special member function is user-provided if it is user-declared and not explicitly defaulted or deleted on its first declaration. &amp;hellip;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;言归正传，似乎实际当中像开头这样，直接定义一个const对象的不多，但是如果一定要这样，有这么几个办法：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;定义一个默认构造函数（好吧。。。）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;const A a=A();&lt;/code&gt;相当于&lt;code&gt;const int a=3;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;const A a{};&lt;/code&gt;值初始化&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>aggregates and pod</title>
      <link>http://shamaoxiaogui.github.io/post/aggregates_and_pod/</link>
      <pubDate>Tue, 26 Jul 2016 14:32:39 +0800</pubDate>
      
      <guid>http://shamaoxiaogui.github.io/post/aggregates_and_pod/</guid>
      <description>

&lt;p&gt;这篇文章大部分整理自stackoverflow上的一篇&lt;a href=&#34;http://stackoverflow.com/questions/4178175/what-are-aggregates-and-pods-and-how-why-are-they-special&#34;&gt;讨论&lt;/a&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;还记得数组的花括号赋值么？还记得c语言中简单的结构体么？还记得c语言初始化结构体用的memset和bzero么？还记得通过socket发送结构体是怎么实现的么？这些就是cpp中aggregate和pod想要做到的。&lt;/p&gt;

&lt;h2 id=&#34;aggregate&#34;&gt;Aggregate&lt;/h2&gt;

&lt;p&gt;要解释POD(Plain Old Data)，就要首先来说一下aggregate。再进入细节之前先说一下aggregate能做什么。aggregate可以用花括号初始化～～，是的，就这么简单。再深一点，它翻译成中文就是聚合，就是说把一堆成员放到一起，并没有面向对象思想中对象的概念，它只是一个数据集合。
接下来看下它的定义，首先看下primer5th中的定义：&lt;/p&gt;

&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;所有成员都是public的&lt;/li&gt;
&lt;li&gt;没有定义任何构造函数&lt;/li&gt;
&lt;li&gt;没有类内初始值&lt;/li&gt;
&lt;li&gt;没有基类和virtual函数&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;03标准的定义&#34;&gt;03标准的定义&lt;/h2&gt;

&lt;p&gt;这些定义实际上柔和类c++11标准在里面，我们先看03标准的表述：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;An aggregate is an array or a class (clause 9) with no user-declared constructors (12.1), no private or protected non-static data members (clause 11), no base classes (clause 10), and no virtual functions (10.3).&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;然后来把这段话拆开：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;数组一定是aggregate的（哪怕里面放的数据成员不是aggregate的）&lt;/li&gt;
&lt;li&gt;aggregate类（标准中的class可以指class和struct以及union）不能有用户声明的构造函数（包括默认、拷贝和移动，以及其它任何构造函数）&lt;/li&gt;
&lt;li&gt;aggregate类的非静态成员必须都是public的（静态成员就无所谓了）&lt;/li&gt;
&lt;li&gt;aggregate类没有基类和虚函数。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;好嘛，这么多，原谅我的脑容量。其实很好理解，之前说过，aggregate这个概念就是为了表明数据的聚集体，那么数组自然就是数据的聚集体，而对于一个类来说，它的数据只有非静态数据成员，而静态数据成员、成员函数等等实际上都可以看作是对这个类定义的操作。有点绕口也有些抽象，那么我们就来逐条看下这些要求。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;不能有任何用户定义的构造函数。如果有会怎么样？如果有的话编译器就会认为你这个类不能“简单的”初始化了,就是说编译器会觉得你这个类可能还会需要分配空间意外的其它操作，这就跟“聚合”这个概念不符了。（即使是定义了一个鸡毛都不干的默认构造函数都不行！！！虽然感觉这样也不破坏聚合的概念）&lt;/li&gt;
&lt;li&gt;非静态成员都是public的，如果是private和protected的话，亲，你要访问数据成员还得定义接口啊。。。虽然也可以，但是，编译器不知道啊，后面还会讨论花括号赋值的内容会继续说这点。&lt;/li&gt;
&lt;li&gt;不能有基类和虚函数。基类和虚函数都会在一定程度上破坏聚合的概念，更重要的，它们的存在会迫使编译器生成“不简单”（实际上是notrivial）的合成默认构造函数，详见《深入理解c++对象模型》&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;ok，这三条大致分析了一下，接下来我们看一下aggregate类的使用。还记得我们说数组一定是aggregate的对吧，那就先想想数组怎么初始化：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;type array[m]={a1,a2,a3...an};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;那么，针对m和n，我们有如下分析：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;if m == n
    array数组中完美的存放a1到an这些元素
elseif m &amp;gt; n
    array数组中的前n个空间存放a1到an，后面的元素执行值初始化（也就是会调用它们的默认构造函数）
else （这时候就是a[]={a1...an}的情形）
    这时候没有显示声明array的大小，它会按照元素的数量（n）来定义一个数组存放a1到an
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;那么我们说aggregate类也是数据的聚集，也可以使用花括号来赋值，类比数组，看一下下面这个例子：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;struct X
{
  int i1;
  int i2;
};
struct Y
{
  char c;
  X x;
  int i[2];
  float f; 
protected:
  static double d;
private:
  void g(){}      
}; 

Y y = {&#39;a&#39;, {10, 20}, {20, 30}};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面的例子当中，对于Y，其数据元素除了最后一个float f，其它都有初始值，而f则进行了默认初始化。其子类x也是一个aggregate类，所以可以由嵌套的花括号初始化。现在你想，如果成员不是public的，这种初始化能行么。。。。
例子：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;iostream&amp;gt;
class noaggregate{
    int x;
};
struct aggregate{};
struct noaggregate1{
    noaggregate1(){};
    int n;
};
struct aggregate1{
    aggregate1&amp;amp; operator=(const aggregate&amp;amp;){return *this;}
    ~aggregate1(){}
    double d;
private:
    static int hehe;
};
int main(){
    // noaggregate ng={1}; //err: no matching ctor
    noaggregate ng; //ok
    // noaggregate1 ng1={2};//err: no matching ctor
    noaggregate1 ng1; //ok
    aggregate1 ag1={3.14}; //ok
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最后，我们来对标准定义进行小小的探索。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;不能有任何&lt;strong&gt;&lt;em&gt;显示定义的&lt;/em&gt;&lt;/strong&gt;构造函数，但是可以有&lt;strong&gt;&lt;em&gt;显式声明的拷贝赋值运算符&lt;/em&gt;&lt;/strong&gt;，以及&lt;strong&gt;&lt;em&gt;显示的析构函数&lt;/em&gt;&lt;/strong&gt;，同时，如果一个类中有引用类型的成员，或者const成员，那必然需要一个显式的构造函数，所以不能有这两种成员。（而且注意到，对于含有非静态成员的类而言，如果不提供显示的默认构造函数，是不能定义一个该类的const对象的，因为所有const变量都需要在定义时初始化）&lt;/li&gt;
&lt;li&gt;非静态成员必须是public的，但是你可以有各种访问控制（public、private、protected）的成员函数和静态成员&lt;/li&gt;
&lt;li&gt;注意了，对数组而言，其元素是不是aggregate不影响数组的aggregate属性，同样，类的成员（不管静态还是非静态）是不是aggregate也不会影响它的aggregate属性。(非aggregate没有“感染性”)&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;这就是03标准对aggregate的定义了，aggregate实现了c语言中对结构体的花括号赋值，更重要的是它提供了一种数据集合的概念。&lt;/p&gt;

&lt;h3 id=&#34;11标准对aggregate定义的改进&#34;&gt;11标准对aggregate定义的改进&lt;/h3&gt;

&lt;p&gt;先来看下11标准中的定义：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;An aggregate is an array or a class (Clause 9) with no user-provided constructors (12.1), no brace-or-equal-initializers for non-static data members (9.2), no private or protected non-static data members (Clause 11), no base classes (Clause 10), and no virtual functions (10.3).
不一样的地方主要有两点：&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;现在不能有user-provided constructors，之前是不能有user-declared constructors。有什么区别呢？主要是因为11标准引入了主动声明使用编译器合成的构造函数机制。所以现在可以这样用了：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;struct X{
    X()=default;
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个声明是说使用编译器合成的默认构造函数，但是它确实是user-declared constructors。。所以新标准在这里进行了改动，允许这种用法在aggregate类中存在。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;非静态成员不能有brace-or-equal-initializers。什么叫brace-or-equal-initializers呢，看下面这个例子：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;struct Y{
    int x=2;
    double d=3.14;
    char ch{&#39;x&#39;};
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;懂了吧。。。11标准引入了类内初始值的概念，可以对类成员使用＝或大括号进行类内初始化，实际上最终编译器也会将其作为构造函数的一部分，所以不能有这些。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;现在，你可以回过头去对照primer5th提供的定义再好好的研究下aggregate类了，它将是我们下面所要探索的POD类型的基础。&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&#34;2016-07-28添加&#34;&gt;2016-07-28添加：&lt;/h3&gt;

&lt;p&gt;事实上，不只有aggregate变量可以用花括号进行初始化。早在11标准之前，就允许对部分类进行explicit initialization。但是有个限制就是花括号列表中的值必须为编译期可确定的常量。它对类的要求就是，成员都是public的。&lt;/p&gt;

&lt;h2 id=&#34;pod&#34;&gt;POD&lt;/h2&gt;

&lt;p&gt;还记得我们在开篇时提到的那几个问题么，关于c的结构体的那几个。好吧，现在假设我们需要用c++来实现一个功能，这个功能作为某个大型软件工程的扩展，而这个工程又是c写的，它传给我们的数据是一个c的结构体，要求我们传回的也是一个c结构体怎么办？好吧，我知道你们有更好更聪明的办法，但是这里我们采用c++的POD类型来解决。
假设我们认可POD类的这个功能，就是可以用来作为导出给c的接口，我们来试着逆推一下POD的特性：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;应该可以实现像c的结构体一样的复制能力，比如同类型不同实例结构体之间的复制（不考虑指针复制带来的内存管理问题）这种复制应该是位逐次复制（bitwise copy，相对于memberwise copy）&lt;/li&gt;
&lt;li&gt;应该有和“同样声明”的c结构体一样的内存布局，这样c才能用memcpy来拷贝它。（就好像将一个结构体序列化写入一个文件，再从这个文件中序列化读出一样，主角必须要有相同的内存分布，否则对数据的解读就会出错）。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;那么，看一下aggregate类是否满足这些条件，因为如果它满足了，我们还要POD干嘛。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;同类型的复制。还记得我们在之前说过aggregate类中可以定义赋值运算符么。。。。&lt;/li&gt;
&lt;li&gt;内存布局。还记得我们说aggregate类的成员可以是非aggregate的么。。。。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;所以aggregate类是不满足这些条件的，但是我们发现满足这些条件的一定是aggregate类（这里大家不要纠结非静态成员变量的访问权限是不是public这个问题，后面11标准也进行了相应的改进。至于其它条件，c的结构体本身就是符合位逐次复制机制的，所以相对应满足上面第一个条件的类也应该是位逐次复制机制，这种类只有用户不显示的定义任何构造函数编译器才会为其产生相应机制的默认构造函数和赋值构造函数。而对于虚函数与基类，研究过c++对象模型的同学应该会清楚它们对类内存布局的一些影响，所以也不详谈），也就是说POD类也是aggregate类。
这里列出的两点只是为了让大家有一个感性上的认识，接下来才是严格的定义。&lt;/p&gt;

&lt;h2 id=&#34;03标准的定义-1&#34;&gt;03标准的定义&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;A POD-struct is an aggregate class that has no non-static data members of type non-POD-struct, non-POD-union (or array of such types) or reference, and has no user-defined copy assignment operator and no user-defined destructor. Similarly, a POD-union is an aggregate union that has no non-static data members of type non-POD-struct, non-POD-union (or array of such types) or reference, and has no user-defined copy assignment operator and no user-defined destructor. A POD class is a class that is either a POD-struct or a POD-union.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;blablabla&amp;hellip;呵呵，读的我尴尬症都犯了。同样，还是来拆开看：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;POD类是一种aggregate类&lt;/li&gt;
&lt;li&gt;POD类的非静态成员不能有非POD类型，不能有含有非POD类型的数组，不能有引用&lt;/li&gt;
&lt;li&gt;POD类不能有用户定义的赋值运算符和析构函数&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;哦，又到了发散思维抠字眼的时候了，首先我们很高兴，因为我们的推断是正确的：POD类都是aggregate的。接下来看后面两条：&lt;/p&gt;

&lt;p&gt;1.
不能有非POD类型的成员。之前我们说非aggregate是没有“感染性”的，那么非POD就是有感染性的。就是说如果一个类的某个成员非POD，那么这个类也必然非POD。为什么要做这样的要求呢？我们可以这样理解，非POD类，要么没有一个兼容c结构体的内存布局（这会导致它“组成”的类的布局也与传统的c结构体不兼容，比如虚表指针、虚基类都是不兼容的因素），要么就不能执行位逐次拷贝或者notrivial（这会导致编译器生成trivial的构造函数失败，影响位逐次拷贝机制，详见《深入理解c++对象模型》），要么两者兼而有之，所以才有这条限制。
1. 不能有用户提供的赋值运算符和析构函数。用户提供了这些，就意味着类中的成员需要资源管理，传统的c结构体可是没有这个概念的。或者仍然可以从位逐次拷贝机制来理解。&lt;/p&gt;

&lt;p&gt;例子：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;struct POD
{
  int x;
  char y;
  void f() {} //no harm if there&#39;s a function
  static std::vector&amp;lt;char&amp;gt; v; //static members do not matter
};

struct AggregateButNotPOD1
{
  int x;
  ~AggregateButNotPOD1() {} //user-defined destructor
};

struct AggregateButNotPOD2
{
  AggregateButNotPOD1 arrOfNonPod[3]; //array of non-POD class
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;那么POD类型的特性：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;POD可以用做向c活着.net导出数据的数据结构&lt;/li&gt;
&lt;li&gt;POD的生命周期始于空间分配，终于空间回收；而非POD则始于构造完成，终于析构开始。（POD没有显示定义的dctor的原因）&lt;/li&gt;
&lt;li&gt;POD可以使用memcpy、memset等函数，保证memcpy拷贝给一块足够大的内存再拷贝回来其数据不变&lt;/li&gt;

&lt;li&gt;&lt;p&gt;c++不允许goto从一个还未定义某个变量的作用域跳过一个变量的定义而进入它的作用域，但是POD可以：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;int f()
{
  struct NonPOD {NonPOD() {}};
  goto label;
  NonPOD x;     //bad
label:
  return 0;
}

int g()
{
  struct POD {int i; char c;};
  goto label;
  POD x;    //ok
label:
  return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;POD保证其内存开始处不会有padding（因为没有基类虚函数而且成员都是POD的，而aggregate虽然也没有基类虚函数，但是有可能第一个成员是非aggregate的带虚函数的类，那仍然会有padding），这样对于一个POD类A，它的第一个成员为T，可以使用reinterpret_cast完成A*与T*的转化。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;11标准对pod类定义的改进&#34;&gt;11标准对POD类定义的改进&lt;/h3&gt;

&lt;p&gt;好吧，终于到最后了。11标准对POD类的定义改动还是比较大的，但整体上来说是放宽了限制。
11标准中，POD类被定义为需要满足以下两条特性：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;支持静态初始化（静态初始化，可以简单理解为，一个放在data段的（全局或着静态）数据，在进程运行前，其初始化的值可以由操作系统直接从可执行文件镜像中加载到内存，虽然可能不太准确但是可以这样粗略理解）。&lt;/li&gt;
&lt;li&gt;POD类在c++中编译出的内存布局与在c中编译出的内存布局相同&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;所以相对应的POD类被拆分为trivial和Standard-layout两部分。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;trivial类支持静态初始化，其要求有：&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
&lt;p&gt;A trivially copyable class is a class that:&lt;/p&gt;

&lt;p&gt;— has no non-trivial copy constructors (12.8),&lt;/p&gt;

&lt;p&gt;— has no non-trivial move constructors (12.8),&lt;/p&gt;

&lt;p&gt;— has no non-trivial copy assignment operators (13.5.3, 12.8),&lt;/p&gt;

&lt;p&gt;— has no non-trivial move assignment operators (13.5.3, 12.8), and&lt;/p&gt;

&lt;p&gt;— has a trivial destructor (12.4).&lt;/p&gt;

&lt;p&gt;A trivial class is a class that has a trivial default constructor (12.1) and is trivially copyable.&lt;/p&gt;

&lt;p&gt;[ Note: In particular, a trivially copyable or trivial class does not have virtual functions or virtual base classes.—end note ]&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;那么trivial与nontrivial的区别：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;A copy/move constructor for class X is trivial if it is not user-provided and if&lt;/p&gt;

&lt;p&gt;— class X has no virtual functions (10.3) and no virtual base classes (10.1), and&lt;/p&gt;

&lt;p&gt;— the constructor selected to copy/move each direct base class subobject is trivial, and&lt;/p&gt;

&lt;p&gt;— for each non-static data member of X that is of class type (or array thereof), the constructor selected to copy/move that member is trivial;&lt;/p&gt;

&lt;p&gt;otherwise the copy/move constructor is non-trivial.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
&lt;li&gt;而Standard-layout则满足第二个特性&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
&lt;p&gt;A standard-layout class is a class that:&lt;/p&gt;

&lt;p&gt;— has no non-static data members of type non-standard-layout class (or array of such types) or reference,&lt;/p&gt;

&lt;p&gt;— has no virtual functions (10.3) and no virtual base classes (10.1),&lt;/p&gt;

&lt;p&gt;— has the same access control (Clause 11) for all non-static data members,&lt;/p&gt;

&lt;p&gt;— has no non-standard-layout base classes,&lt;/p&gt;

&lt;p&gt;— either has no non-static data members in the most derived class and at most one base class with non-static data members, or has no base classes with non-static data members, and&lt;/p&gt;

&lt;p&gt;— has no base classes of the same type as the first non-static data member.&lt;/p&gt;

&lt;p&gt;A standard-layout struct is a standard-layout class defined with the class-key struct or the class-key class.&lt;/p&gt;

&lt;p&gt;A standard-layout union is a standard-layout class defined with the class-key union.&lt;/p&gt;

&lt;p&gt;[ Note: Standard-layout classes are useful for communicating with code written in other programming languages. Their layout is specified in 9.2.—end note ]&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;详细的解释见文章开头的链接。主要注意是，11标准放宽类限制，现在所有成员只要有相同的访问控制就好了（因为之前的标准对不同访问控制的成员内存分布没有做限定，这样可以防止成员的不连续存放）。再者，禁止第一个非静态成员和基类类型相同，是因为如果类的第一个非静态成员与基类类型相同，它们会共享相同的地址。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>深入理解cpp对象模型 第四章笔记</title>
      <link>http://shamaoxiaogui.github.io/post/inside_cpp_object_model_ch4/</link>
      <pubDate>Tue, 26 Jul 2016 10:31:23 +0800</pubDate>
      
      <guid>http://shamaoxiaogui.github.io/post/inside_cpp_object_model_ch4/</guid>
      <description>&lt;p&gt;第四章主要是对成员函数的讲解：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;对于static成员函数：

&lt;ol&gt;
&lt;li&gt;不可以直接存取nonstatic成员&lt;/li&gt;
&lt;li&gt;不可以是const限定的&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;对于非静态成员函数的处理：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;在函数签名（函数名，参数数量，参数类型）中添加一个新参数，this指针。&lt;/li&gt;
&lt;li&gt;将其中对非静态成员的存取改为this指针操作&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;struct Someclass{
    void func(){n+=3;}
    int n;
};
Someclass::func();
//expand to
void func(Someclass *const this){ //magic here
    this-&amp;gt;n+=3;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意到扩展出的this是一个const的指针，也就是说在非静态成员函数中我们不能修改传入的this指针。同样，如果非静态成员函数是const限定的，那么传入的const会同时有顶层和底层const属性，也就限定了函数不得修改this和this指向的类。
c++保证，非静态成员函数至少应该和一般的非成员函数有相同的效率。
对函数名的处理，一般在函数名中添加所属类、函数签名（不包括函数返回值）信息，这样来区分重载函数以及父子类间的虚函数等。这样在编译链接不同的文件时，如果函数参数类型不同链接会出错，但是如果函数返回值类型声明错了就没法检查出来了（不同的编译器都不太一样）&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;对于指针或者引用调用的虚函数，编译器会将其扩展为由虚表指针指向的虚表中的相应函数指针，效率会损失。而由对象调用的虚函数，则复合一般成员函数调用规则，效率高如果虚函数是inline的，使用对象调用时编译器可以将其展开，效率会更高。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;对于静态成员函数：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;不能直接存取类中的非静态成员&lt;/li&gt;
&lt;li&gt;不能被声明为const、volatile、virtual（原因在于，静态成员函数被编译器当作非成员函数对待，不会传给他类的this指针，而const和volatile修饰的函数需要传入一个&lt;code&gt;const A * const this&lt;/code&gt;或&lt;code&gt;volatile A * const this&lt;/code&gt;指针，而virtual函数也需要this指针来查找虚表）&lt;/li&gt;
&lt;li&gt;不需要经由对象才能调用&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;iostream&amp;gt;
struct statictest{
    // static void hehe()const{std::cout&amp;lt;&amp;lt;&amp;quot;static func&amp;quot;&amp;lt;&amp;lt;std::endl;}
    // static void hehe()volatile{std::cout&amp;lt;&amp;lt;&amp;quot;static func&amp;quot;&amp;lt;&amp;lt;std::endl;}
    // static virtual void hehe(){std::cout&amp;lt;&amp;lt;&amp;quot;static func&amp;quot;&amp;lt;&amp;lt;std::endl;}
    static void hehe(){std::cout&amp;lt;&amp;lt;&amp;quot;static func&amp;quot;&amp;lt;&amp;lt;std::endl;}
    statictest&amp;amp; func(){std::cout&amp;lt;&amp;lt;&amp;quot;func run&amp;quot;&amp;lt;&amp;lt;std::endl;return *this;}
private:
    int n;
};
int main(){
    statictest st;
    st.func().hehe();
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ ./static.out
func run
static func
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个例子说明，虽然调用静态函数不需要对象，但是有的编译器还是会对获得对象的表达式进行运算还有，对静态成员函数取地址，得到是是一个非成员函数指针&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;关于继承体系中的虚函数，书中有两点建议：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;由于多继承时虚函数调用开销加大，编译器会对短的虚函数进行优化，所以虚函数尽量写的短一些。&lt;/li&gt;
&lt;li&gt;不要在虚基类中定义非静态成员，编译器会做一些复杂的操作，影响性能。&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;成员函数指针的讨论：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;静态成员、静态成员函数、非静态成员函数的指针都是其实际内存地址，但是对于非静态成员函数，调用还需要提供this指针，所以这个地址是“不完整”的&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;iostream&amp;gt;
using namespace std;
class Someclass{
public:
    static void sfunc(){cout&amp;lt;&amp;lt;&amp;quot;static func&amp;quot;&amp;lt;&amp;lt;endl;}
    static int smember;
    void nsfunc(){cout&amp;lt;&amp;lt;&amp;quot;nonstatic func&amp;quot;&amp;lt;&amp;lt;endl;};
    int nsmember;
};
int Someclass::smember=1;
int main(){
    void (*sfp)();
    int *smp;
    void (Someclass::*nsfp)();
    int Someclass::*nsmp;
    sfp=&amp;amp;Someclass::sfunc;
    smp=&amp;amp;Someclass::smember;
    nsfp=&amp;amp;Someclass::nsfunc;
    nsmp=&amp;amp;Someclass::nsmember;
    printf(&amp;quot;p sfp: %p\n&amp;quot;,sfp);
    printf(&amp;quot;p smp: %p\n&amp;quot;,smp);
    printf(&amp;quot;p nsfp: %p\n&amp;quot;,nsfp);
    printf(&amp;quot;p nsmp: %p\n&amp;quot;,nsmp);
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ ./memberpointer.out
p sfp: 0x10cf11150
p smp: 0x10cf120e8
p nsfp: 0x10cf11190
p nsmp: 0x0
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;而虚函数成员指针的调用则更加复杂和低效。通常编译器可以在编译期判断调用是否为虚函数，对于非虚函数，直接使用指针指向的函数地址，而对于虚函数，由于编译器无法确定最终调用的是哪个函数，往往使用一些终端手段。比如在成员虚函数指针中存放该虚函数在虚表中的索引，再间接调用。对于我们用户而言，只需要知道虚函数的指针与普通成员函数指针同样使用，也可以运行时多态，但是效率更低就好了。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;iostream&amp;gt;
using namespace std;
struct base{
    virtual void func(){cout&amp;lt;&amp;lt;&amp;quot;base func&amp;quot;&amp;lt;&amp;lt;endl;}
    virtual ~base()=default;
};
struct derived:public base{
    void func(){cout&amp;lt;&amp;lt;&amp;quot;drived func&amp;quot;&amp;lt;&amp;lt;endl;}
};
int main(){
    void (base::*bpf)()=&amp;amp;base::func;
    base *bp=new derived;
    (bp-&amp;gt;*bpf)();
    delete bp;
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ ./virtualpointer.out
drived func
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;最后，inline函数在引发参数副作用的时候（比如形参传入了一个函数调用，本意是使用该函数的返回值做形参），通常会引入局部变量。inline内部的局部变量也会因为展开而参与name mangling。所以大量调用inline容易产生大量局部变量&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>深入理解cpp对象模型 第三章笔记</title>
      <link>http://shamaoxiaogui.github.io/post/inside_cpp_object_model_ch3/</link>
      <pubDate>Sun, 24 Jul 2016 11:10:27 +0800</pubDate>
      
      <guid>http://shamaoxiaogui.github.io/post/inside_cpp_object_model_ch3/</guid>
      <description>&lt;p&gt;前言描述了一个很有趣的问题，下面的类X，Y，Z，和A的sizeof各是多大？&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;iostream&amp;gt;
struct X{};
struct Y:public virtual X{};
struct Z:public virtual X{};
struct A:public Y,public Z{};
int main(){
    std::cout&amp;lt;&amp;lt;&amp;quot;X: &amp;quot;&amp;lt;&amp;lt;sizeof(X)&amp;lt;&amp;lt;std::endl;
    std::cout&amp;lt;&amp;lt;&amp;quot;Y: &amp;quot;&amp;lt;&amp;lt;sizeof(Y)&amp;lt;&amp;lt;std::endl;
    std::cout&amp;lt;&amp;lt;&amp;quot;Z: &amp;quot;&amp;lt;&amp;lt;sizeof(Z)&amp;lt;&amp;lt;std::endl;
    std::cout&amp;lt;&amp;lt;&amp;quot;A: &amp;quot;&amp;lt;&amp;lt;sizeof(A)&amp;lt;&amp;lt;std::endl;
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ ./sizeof.out
X: 1
Y: 8
Z: 8
A: 16
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们来分析一下。首先，注意到上面三个类都是所谓的空类，就是没有数据成员的。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;对于A，确实是个空类，没有虚函数意味着没有虚表指针，没有继承关系也不需要编译器添加特别的数据部分。这时他的大小是1个字节，因为为了使A的不同实例有不同的地址，所以编译器对其进行了小填充。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;struct A{
    char _ch;
};
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;对于X和Y，其实并不是完全的空类。虽然没有虚表指针，但是它们虚继承了A，所以编译器必然会给它们添加一些成员：添加一个指针，指向虚基类或一个表格，表格中存放虚基类的地址或者其偏移量。我们来分析下这种做法。我用的mac是64位机，也就是指针大小为8字节，那么Y／Z的大小为&lt;code&gt;8(virtual base pointer)+1(virtual base class)+7(alignment padding)=16bytes&lt;/code&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;struct Y{
    void *vbtr;     //to A, 8bytes
    A aa;   //1byte
    //padding 7bytes
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;而结果为8byte与我们的计算不复。这里实际上编译器执行了一种优化：空虚基类（empty virtual base class ）通常用于提供一个virtual interface，那就将这种基类当作优化为派生类的数据成员好了，也就是直接将它放到派生类的开头部分，不再需要用虚基类指针指向它。这样的话，之前“空”的派生类现在“有”了一个成员，那么就没有必要给他添加1byte来区分类的不同对象，也就是将上面第一条的1个字节给省掉了，那么也就不需要最后7个字节的alignment padding了，而需要的是对虚基类占用空间的padding。所以大小为&lt;code&gt;1(virtual base class)+7(alignment padding)=8bytes&lt;/code&gt;。反过来，如果X中原本就有数据成员，就不会出现这种编译器优化差异。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;struct Y{
    A aa;   //1byte
    //padding 7bytes
};
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;最后来看A，记住在继承链中不论出现多少次，虚基类只有一个实体。假设编译器没有优化：&lt;code&gt;8(vbtr in Y)+8(vbtr in X)+1(virtual base class)+7(alignment padding)=24bytes&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;struct A{
    void *vbtr_Y;   //vbtr in Y, 8bytes
    void *vbtr_X;   //vbtr in X, 8bytes
    A aa;   //virtual base class, 1byte
    //padding 7bytes
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;而进行优化后，大小为&lt;code&gt;8(Y)+8(Z)=16bytes&lt;/code&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;struct A{
    Y yy;   // 8bytes
    Z zz;   // 8bytes
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;现代C++标准对类的成员函数的解析，是在对类的解析完成后才开始的。所以，将类成员声明在成员函数之后，对成员函数中调用这些成员的语义没什么影响，但是，成员函数的签名却是按顺序解析的，即在类完全解析完之前，成员函数签名就解析完了，这有可能带来如下的影响：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;typedef int length;
extern int x;
struct someclass{
    //...
    length func(){return x;} //这里编译器对x的解读是没问题的，因为到类解析完编译器才会解析成员函数的内容。但是对于声明中的length就不是这样了，它会按顺序解析，也就会把length解析为int
    //...
private:
    typedef double length;
    length x;
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;所以，&lt;strong&gt;&lt;em&gt;永远把类要用到的typrdef放到类声明的起始处&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;对于类中的数据成员，标准只规定，同一access section（private。。。）中靠后的数据成员地址高，并没有说一定要连续。所以有时为了内存对齐，成员直接会有padding。静态成员不管声明在哪都不会占空间。vptr的位置视编译器而定，大多放在类的开始。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;类的成员的存取。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;静态成员，静态成员存储在全局区，所以类的继承关系、访问权限、指针还是对象访问，用类直接访问还是用对象访问对其访问效率都没有影响。要注意的是下面亮点：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;见如下代码：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;foobar().chunkSize=500;
//
(void)foobar();
Point3d.chunkSize=500;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;编译器会进行如上变换。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;如果两个不同的类都声明了同名的静态成员，那么编译器会进行name-mangling，变换齐名称&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;非静态成员：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;origin._y=0.0;
//
*(&amp;amp;origin+(&amp;amp;Point3d::_y-1))=0.0;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里编译器会进行地址的转化，转化为类的地址加上成员的偏移地址。之所以要减一，是因为类成员指针总是指向类成员加一的位置，这样就可以区分一个类成员指针没有指向任何一个成员的情况。
对于如下代码：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;origin.x=0.0;
pt-&amp;gt;x=0.0;  //pt=&amp;amp;origin
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在通常，执行效率没有任何不同，但是，如果origin是一个虚拟继承的派生类，并且x是派生类的成员，这时效率就会有重大差异。因为在编译时不知道pt中存放的具体是哪种类型，就无法用静态地址去替换它，只能依靠一些动态手段（vptr、vbtr）；而origin的类型是可以确定的，编译器会解析出它的静态地址。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;继承时的布局。一般是派生类扩展基类，虚表指针放在顶部。多继承时，内存上先放第一个基类，再放第二个。。。涉及到虚基类，记住虚基类只有一个实体，直接继承虚基类的派生类会有虚基类指针，指向虚基类或者是其偏移量。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;关于成员存取的效率，也许对于虚拟继承基类中成员的存取会慢一点，但是现代编译器的优化都做的比较好，问题不大。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;最后，类成员指针总是存储的是成员在类内的偏移量，书上说这个偏移量还会加一，以区分其不指向对象的情况，但是g++测试表面编译器对此进行了内部优化，使其直接表示偏移量。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;cstdio&amp;gt;
struct sc{
    virtual void func(){}
    char ch;
    int x;
};
int main(){
    sc scc;
    printf(&amp;quot;&amp;amp;scc.ch %p\n&amp;quot;,&amp;amp;scc.ch);
    printf(&amp;quot;&amp;amp;scc.x %p\n&amp;quot;,&amp;amp;scc.x);
    printf(&amp;quot;sc::ch %p\n&amp;quot;,&amp;amp;sc::ch);
    printf(&amp;quot;sc::x %p\n&amp;quot;,&amp;amp;sc::x);
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ ./classptr.out
&amp;amp;scc.ch 0x7fff5d4b37f0
&amp;amp;scc.x 0x7fff5d4b37f4
sc::ch 0x8
sc::x 0xc
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>深入理解cpp对象模型 第二章笔记</title>
      <link>http://shamaoxiaogui.github.io/post/inside_cpp_object_model_ch2/</link>
      <pubDate>Sat, 23 Jul 2016 09:44:58 +0800</pubDate>
      
      <guid>http://shamaoxiaogui.github.io/post/inside_cpp_object_model_ch2/</guid>
      <description>

&lt;p&gt;构造函数部分：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;先复习下primer对合成默认构造函数的叙述：

&lt;ol&gt;
&lt;li&gt;构造函数不能使用const限定符，一个const对象直到构造函数完成时才获得其“常量”属性。&lt;/li&gt;
&lt;li&gt;编译器只有发现类不包含任何构造函数的情况下才会生成一个默认构造函数。&lt;/li&gt;
&lt;li&gt;如果类中包含没有默认构造函数的类成员，就无法生成合成默认构造函数。&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;inside中，一个没有任何构造函数的类会有一个隐式声明的trivial（没啥用的）构造函数，在以下情况则会有nontrivial（有用的，编译器所需要的，我的理解是，就是我们通常说的合成默认构造函数）&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;如果一个类没有任何构造函数且所有的类成员都有默认构造函数，那么编译器会合成一个默认构造函数（在需要的时候，也就如果在代码中实际定义类的实体才会生成），按类成员的声明顺序来调用它们的默认构造函数。而内置变量成员的初始化则是程序员的责任。如果程序员提供了一个构造函数，来进行内置成员变量的初始化，则编译器会按照上述规则扩充这个函数。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;iostream&amp;gt;
using namespace std;
class c1{
public:
    c1(){cout&amp;lt;&amp;lt;&amp;quot;c1 ctor&amp;quot;&amp;lt;&amp;lt;endl;}
    c1(const c1&amp;amp;){cout&amp;lt;&amp;lt;&amp;quot;c1 copy ctor&amp;quot;&amp;lt;&amp;lt;endl;}
};
class c2{
public:
    c2(){cout&amp;lt;&amp;lt;&amp;quot;c2 ctor&amp;quot;&amp;lt;&amp;lt;endl;}
    c2(const c2&amp;amp;){cout&amp;lt;&amp;lt;&amp;quot;c2 copy ctor&amp;quot;&amp;lt;&amp;lt;endl;}
    virtual ~c2(){}
};
class c3{
public:
    c2 cc2;
    c1 cc1;
    char *str;
};
class c4{
public:
    c4(){cout&amp;lt;&amp;lt;&amp;quot;c4 ctor&amp;quot;&amp;lt;&amp;lt;endl;n=1;}
    c4(const c4&amp;amp;){cout&amp;lt;&amp;lt;&amp;quot;c4 copy ctor&amp;quot;&amp;lt;&amp;lt;endl;}
    c2 cc2;
    c1 cc1;
    int n;
};
int main(){
    c3 cc3;
    cout&amp;lt;&amp;lt;&amp;quot;===========================&amp;quot;&amp;lt;&amp;lt;endl;
    c4 cc4;
    cout&amp;lt;&amp;lt;&amp;quot;===========================&amp;quot;&amp;lt;&amp;lt;endl;
    c4 cc5(cc4);
    cout&amp;lt;&amp;lt;&amp;quot;sizeof c1 &amp;quot;&amp;lt;&amp;lt;sizeof(c1)&amp;lt;&amp;lt;endl;
    cout&amp;lt;&amp;lt;&amp;quot;sizeof c2 &amp;quot;&amp;lt;&amp;lt;sizeof(c2)&amp;lt;&amp;lt;endl;
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ ./classctor.out
c2 ctor
c1 ctor
===========================
c2 ctor
c1 ctor
c4 ctor
===========================
c2 ctor
c1 ctor
c4 copy ctor
sizeof c1 1
sizeof c2 8
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以发现（调皮的我顺路测试了下空类的大小），编译器确实扩展了程序员编写的构造函数(即使是拷贝构造函数，编译器扩展时活着生成时也是调用类成员的默认构造函数)。另外，为了防止在多个文件（编译模块）中生成多个默认构造函数，编译器&lt;strong&gt;&lt;em&gt;把合成的默认构造函数、拷贝构造函数、析构函数，拷贝赋值运算符都以inline的方式完成&lt;/em&gt;&lt;/strong&gt;，因为inline函数只在当前文件作用域有效，如果函数太复杂，就合成为static非inline函数。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;如果一个没有任何构造函数的子类的父类有默认构造函数，那么编译器会合成一个调用父类默认构造函数的合成默认构造函数。如果程序员提供了构造函数，但是没有提供默认构造函数，编译器不会合成一个默认构造函数，但是会扩展所有的构造函数，调用父类的默认构造函数。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;iostream&amp;gt;
using namespace std;
class father{
public:
    father(){cout&amp;lt;&amp;lt;&amp;quot;father ctor&amp;quot;&amp;lt;&amp;lt;endl;}
};
class son:public father{
public:
    int n;
};
class son2:public father{
public:
    son2(int x){n=x;cout&amp;lt;&amp;lt;&amp;quot;son2 ctor&amp;quot;&amp;lt;&amp;lt;endl;}
    int n;
};
int main(){
    son s;
    cout&amp;lt;&amp;lt;&amp;quot;====================&amp;quot;&amp;lt;&amp;lt;endl;
    // son2 s2; //error
    cout&amp;lt;&amp;lt;&amp;quot;====================&amp;quot;&amp;lt;&amp;lt;endl;
    son2 s3(3);
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ ./fatherctor.out
father ctor
====================
====================
father ctor
son2 ctor
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;如果一个类中有virtual方法，不论是声明还是继承来的，因为需要虚表，所以必然得有构造函数来初始化vptr的值令其指向虚表，这种情况下，没有任何构造函数的类编译器会合成一个默认构造函数（为了初始化虚表），有构造函数的编译器会进行相应的扩展。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;相应的，如果类在继承链上有一个虚继承的基类，那么编译器很可能需要在类中插入一个指向该基类的指针（或者其它机制，总之需要进行一翻操作），这就要求一个构造函数来操作。所以这种情况下，如果类没有任何构造函数编译器就合成一个完成该操作的合成默认构造函数；若有程序员提供的构造函数，编译器就扩展它们。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;总结：以上四种情况说明的是 ，&lt;strong&gt;&lt;em&gt;对编译器而言，有必要合成默认构造函数&lt;/em&gt;&lt;/strong&gt;的情况。也就是编译器合成默认构造函数或者扩展构造函数的目的与作用：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;调用类成员的默认构造函数&lt;/li&gt;
&lt;li&gt;调用父类的默认构造函数&lt;/li&gt;
&lt;li&gt;为类初始化虚表相关的操作&lt;/li&gt;
&lt;li&gt;为类初始化虚基类机制&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;一旦上面四条对于一个类来说都不需要，那么合成的默认构造函数被就是trivial（没有用）的，而实际上编译器不会将这种构造函数生成出来。
还记得primer中有个聚合类（aggregate class），当聚合类不含类成员时，上面四个状态就都不满足，那编译器就不会给他生成合成默认构造函数了。所以：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;任何class没有定义构造函数，编译器会生成一个合成默认构造函数&lt;/li&gt;
&lt;li&gt;编译器合成的默认构造函数会初始化所有类的成员&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;这两个观点都不正确&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;同样，拷贝构造函数也有trivial和nontrivial之分，编译器只会生成nontrivial的拷贝构造函数。而判断trivial的标准就在于类是否展现出位逐次拷贝（Bitwise Copy Semantics）特性。首先，看下primer是怎么说的：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;与合成默认构造函数不同，即使我们定义了其它构造函数，编译器也会为我们合成一个拷贝构造函数。&lt;/p&gt;

&lt;p&gt;而一般情况，合成的拷贝构造函数会将其参数的成员逐个拷贝到正在创建的对象中。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;下面是inside的分析：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;当一个类的成员中有一个类，该类成员有拷贝构造函数（不论是它显示声明的，还是编译器因为非位逐次拷贝而生成的。第二个说法有点绕口，其实就是说，如果该类成员也有一个有拷贝构造函数的类成员。。。。递归中。。。。）&lt;/li&gt;

&lt;li&gt;&lt;p&gt;当类的继承链上有一个有拷贝构造函数（和上面括号中描述的一样，两种情况），这两种情况下类是无法进行位逐次拷贝的，此时编译器会生成一个默认拷贝构造函数来调用类成员／基类的拷贝构造函数：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;iostream&amp;gt;
using namespace std;
struct bitwise{
    int n;
    char *hehe;
};
struct goodcopy{
    goodcopy(){}
    goodcopy(const goodcopy&amp;amp;){cout&amp;lt;&amp;lt;&amp;quot;good copy!!&amp;quot;&amp;lt;&amp;lt;endl;}
};
struct nonbitwise{
    goodcopy gc;
};
struct nonbitwise2:public goodcopy{

};
struct nonbitwise3{
    nonbitwise3(){}
    nonbitwise3(const nonbitwise3&amp;amp;){}
    goodcopy gc;
};
int main(){
    bitwise bw1;
    char * str=&amp;quot;blabla!&amp;quot;;
    bw1.hehe=str;
    bw1.n=1;
    bitwise bw2(bw1);
    cout&amp;lt;&amp;lt;&amp;quot;bw1 n &amp;quot;&amp;lt;&amp;lt;bw1.n&amp;lt;&amp;lt;&amp;quot; hehe &amp;quot;&amp;lt;&amp;lt;bw1.hehe&amp;lt;&amp;lt;endl;
    cout&amp;lt;&amp;lt;&amp;quot;bw2 n &amp;quot;&amp;lt;&amp;lt;bw2.n&amp;lt;&amp;lt;&amp;quot; hehe &amp;quot;&amp;lt;&amp;lt;bw2.hehe&amp;lt;&amp;lt;endl;
    cout&amp;lt;&amp;lt;&amp;quot;=============================&amp;quot;&amp;lt;&amp;lt;endl;
    nonbitwise nbw1;
    nonbitwise nbw12(nbw1);
    cout&amp;lt;&amp;lt;&amp;quot;=============================&amp;quot;&amp;lt;&amp;lt;endl;
    nonbitwise2 nbw2;
    nonbitwise2 nbw22(nbw2);
    cout&amp;lt;&amp;lt;&amp;quot;=============================&amp;quot;&amp;lt;&amp;lt;endl;
    nonbitwise3 nbw3;
    nonbitwise3 nbw32(nbw3);
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ ./bitwisecopy.out
bw1 n 1 hehe blabla!
bw2 n 1 hehe blabla!
=============================
good copy!!
=============================
good copy!!
=============================

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面的代码中，不能进行位逐次拷贝的nonbitwise2和nonbitwise都由编译器生成了nontrivial的拷贝构造函数来调用goodcopy的拷贝构造函数；而nonbitwise3虽然也不能位逐次拷贝，但是由于程序员定义了拷贝构造函数，所以编译器没有为其生成，而且也没有对其进行扩展，这一点与默认构造函数不同
1.
如果一个类中含有虚函数，那这个类中必然会有虚表。这样的话，如果这个类之间进行拷贝（子类到子类，类型相同），使用位逐次拷贝是可以的，因为两个类类型相同，虚表指针指向相同的虚表。但是考虑这种情况，当一个子类拷贝给一个父类时，仍然使用位逐次拷贝，可以么？这种情况下的拷贝会发生子类的截断，即只拷贝其基类部分。而位逐次拷贝会使基类的虚表指针指向子类的虚表，而其子类部分又不存在（因为这货是基类啊）所以不能用位逐次拷贝，需要对虚表指针进行处理。综合一下就是，类中含有虚函数，就不能位逐次拷贝。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;同样的，如果一个类的继承链上存在虚继承关系，也不能单纯的用位逐次拷贝处理子类拷贝给父类的情况，而需要编译器合成一个拷贝构造函数。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;对于拷贝构造在函数传参和返回中的使用，主要注意NRV。先来看一个函数是如何返回一个类的：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;struct someone{
    someone(const someone &amp;amp;x){/*...*/}
//...
}
someone func(int n){
    someone t;
    //...
    return t;
}
someone r=func(1);
//实际中编译器很可能会产生如下代码
void func(int n, someone&amp;amp; ret){
    someone t;
    //...
    ret.someone::someone(t);
}
someone r; //此处不执行someone的默认构造函数
func(1,r);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里就可以发现返回类的函数被处理为通过参数来返回的函数了。这时，完全可以省去临时类t：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;void func(int n, someone&amp;amp; ret){
    ret.someone::someone();
    //...
    return;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这就是NRV优化（Named Return Value），也就是对函数中的中间类直接用返回值的引用替换，省去一个临时类，就省去了一次默认构造和拷贝构造以及一次析构的开销。但是NRV也有缺点：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;不同的编译器，其NRV的实现程度不一样，也就是编译器不一定会实现NRV&lt;/li&gt;
&lt;li&gt;不同复杂度的函数，NRV实现程度也不一样&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;这些不确定性让我们不敢依靠NRV来评估软件性能（所以c++11的右值引用是一大亮点）。另外，关于到底要不要明确的写出拷贝构造函数，总结一下就是，如果类可以位逐次拷贝，那就不要写，因为编译器会生成一个trivial的拷贝构造函数，效率很高，自己写的话很有可能使效率下降。至于书中说的explicit copy constructor与NRV的关系，我查了下，见这篇&lt;a href=&#34;http://www.cnblogs.com/cyttina/archive/2012/11/26/2790076.html&#34;&gt;文章&lt;/a&gt;，就是说，嗯，没关系。。。。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;最后，关于构造函数初始化列表：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;注意初始化顺序，按成员声明的顺序来。尽量不要交织。&lt;/li&gt;
&lt;li&gt;尤其不要用在子类的初始化列表中用子类的成员函数为父类的构造函数提供参数，比如：&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;struct father{
    //...
    father(int n){/*...*/}
    //...
};
struct son:public father{
    //...
    son(int x):_t(x),father(memberfunc(x)){/*...*/}
    //...
    int memberfunc(int n){/*...*/}
    int _t;
};
//...  编译器有可能把初始化列表转化为
// son::son(/*...this pointer...*/){
    // father::father(this,this-&amp;gt;memberfunc(x)); //尼玛，this的son部分还没构建你就以及调用它的方法了！！！！！
    // _t=x;
// }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最后注意，在构造活着析构函数中调用虚函数，虚函数一定是当前构造／析构函数所属类型的虚函数，因为再往下，子类部分要不还没构建，要不就已经析构了。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;

&lt;p&gt;对于构造函数，一句总结就是，如果写了任何构造函数，编译器就不会给你生成默认构造函数了。对于拷贝构造，不需要明确写的就不要写，对于初始化列表，不要“交织”！&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>cpp primer 第十五章笔记</title>
      <link>http://shamaoxiaogui.github.io/post/cpp_primer_note_15/</link>
      <pubDate>Thu, 21 Jul 2016 10:57:42 +0800</pubDate>
      
      <guid>http://shamaoxiaogui.github.io/post/cpp_primer_note_15/</guid>
      <description>&lt;p&gt;终于到了第十五章了，复习大计实施的还不错～～&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;动态绑定可以用指针或者引用实现&lt;/li&gt;
&lt;li&gt;基类的析构函数一般都应该是virtual修饰的，因为通常我们会在一个基类指针中存放一个派生类的指针，delete这个指针时编译器要调用合适的析构函数，讲基类的析构函数定义为virtual的使编译器自动调用派生类的析构函数。不用担心，析构时仍然会调用基类的析构函数&lt;/li&gt;
&lt;li&gt;在用于覆盖虚函数的函数后面可以添加关键字override来显示注明，位置是const和引用限定符后面&lt;/li&gt;
&lt;li&gt;静态成员可以被继承切在整个继承体系中只有一个&lt;/li&gt;
&lt;li&gt;防止继承，在类定义后面加final关键字&lt;/li&gt;
&lt;li&gt;基类的拷贝构造函数不是虚函数，因为用一个派生类给基类赋值只会赋值派生类中的基类部分&lt;/li&gt;
&lt;li&gt;类中普通的成员函数我们可以只提供声明而不定义，只要不使用即可，但是必须为所有的虚函数提供定义，因为直到运行时才会知道哪个虚函数被使用了&lt;/li&gt;
&lt;li&gt;引用和指针的静态类型与动态类型不同这一事实正是C++语言支持多态的根本所在&lt;/li&gt;
&lt;li&gt;如果派生类中覆盖了某个虚函数，它可以再一次使用virtual指定其虚函数属性，然而这是&lt;strong&gt;&lt;em&gt;没必要的&lt;/em&gt;&lt;/strong&gt;，因为一旦某个函数被声明为虚函数，在整个继承体系中它都是虚函数。&lt;/li&gt;
&lt;li&gt;派生类要覆盖虚函数，新函数必须有与虚函数一样的参数和返回值，唯一的&lt;strong&gt;&lt;em&gt;例外&lt;/em&gt;&lt;/strong&gt;是，如果虚函数返回的是类本身（基类）的指针或引用，那么覆盖函数允许返回派生类的指针或引用&lt;/li&gt;
&lt;li&gt;也可以将某个函数指定为final，防止后续派生类覆盖它（一般用于间接派生中，自己定义了一个覆盖父类的虚函数，但是不希望后续子类覆盖它）&lt;/li&gt;
&lt;li&gt;虚函数中使用默认实参是依赖与当前的&lt;strong&gt;&lt;em&gt;静态类型&lt;/em&gt;&lt;/strong&gt;的！！！所以最好将一个虚函数所有的覆盖函数中的默认实参定义成一样的，防止出错&lt;/li&gt;
&lt;li&gt;使用作用域运算符可以回避虚函数机制，静态指定调用目标，这一般用在派生类的虚函数需要调用基类的虚函数做一些操作的时候，此时如果不指定作用域，运行时会被解析为调用自身，从而无限递归&lt;/li&gt;
&lt;li&gt;纯虚函数，带 =0 的虚函数，可以不提供定义（一般不提供），也可以提供，但是必须在类外定义。&lt;/li&gt;
&lt;li&gt;含有（或者直接继承，没有覆盖）纯虚函数的类是抽象基类，抽象基类不能创建对象&lt;/li&gt;
&lt;li&gt;protected成员：

&lt;ol&gt;
&lt;li&gt;用户不可访问，但是对其派生类和其友元是可以访问的（注意是基类的友元）&lt;/li&gt;
&lt;li&gt;对于派生类的友元，想要访问基类的protected成员，只能通过派生类来“代理”访问&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;关于派生类向基类转换的可访问性，引用primer的总结，&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;对于代码中的某个给定节点来说，如果基类的公有成员是可访问的，则派生类向基类的类型转换也是可访问的；反之则不行。&lt;/p&gt;
&lt;/blockquote&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;友元没有传递性，友元也不能继承&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;可以用using声明改变继承来的可访问成员的可访问性（比如把private继承来的某父类成员用using声明变成public的）&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;struct默认访问说明符为public，默认继承保护级别也是public；而class默认访问说明符是private的，默认继承保护级别也是private（but还是显示声明吧。。。）&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;指针和引用的静态类型决定哪些成员可见&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;名字查找先于类型检查，所以派生类中的函数会隐藏掉基类中的同名函数，即使二者函数签名不同，也不会构成函数重载&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;所以说，如果在覆盖虚函数的时候写错了参数，不但不能覆盖虚函数（用基类指针调用虚函数调用的是基类的虚函数），而且还会在派生类中隐藏掉该虚函数（用该派生类指针调用虚函数会报错，因为虚函数被隐藏了），比如：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;iostream&amp;gt;
class base{
public:
    virtual int func(){std::cout&amp;lt;&amp;lt;&amp;quot;base v&amp;quot;&amp;lt;&amp;lt;std::endl;}
};
class d1:public base{
public:
    int func(int n){std::cout&amp;lt;&amp;lt;&amp;quot;d1 func&amp;quot;&amp;lt;&amp;lt;std::endl;}
};
int main(){
    base *bp=new d1;
    d1 *dp=bp;
    bp-&amp;gt;func();     //调用的是base的虚函数func
    //dp-&amp;gt;dunc();     //编译错误，因为对d1而言，base的虚函数func被d1的func(int)隐藏了
    delete bp;
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;起始对于派生类来说，基类的虚函数和非虚函数都可以覆盖，只不过覆盖虚函数可以在其基类指针中动态调用，而非虚函数不行。但是，一旦定义一个名字与基类中某个函数一样的函数，基类中的函数就被覆盖了，基类中的所有的该函数的重载函数也一样。所以如果想在派生类中使用基类的所有重载函数，要不就不要覆盖，要不就把每个重载函数都覆盖。或者，用一条using声明将基类中的函数“拿”到派生类的public域中，然后再覆盖其中要覆盖的函数。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;iostream&amp;gt;
class base{
public:
    void func(){std::cout&amp;lt;&amp;lt;&amp;quot;bfunc&amp;quot;&amp;lt;&amp;lt;std::endl;}
    void func(int n){std::cout&amp;lt;&amp;lt;&amp;quot;bfunc2&amp;quot;&amp;lt;&amp;lt;std::endl;}
    int x=0;
};
class d1:public base{
public:
    using base::func;
    void func(){std::cout&amp;lt;&amp;lt;&amp;quot;dfunc&amp;quot;&amp;lt;&amp;lt;std::endl;}
    using base::x;
    int x=1;
};
int main(){
    d1 d;
    d.func();
    d.func(3);
//    std::cout&amp;lt;&amp;lt;&amp;quot;d.x=&amp;quot;&amp;lt;&amp;lt;d.x&amp;lt;&amp;lt;std::endl;    //二义性错误
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;派生类的构造函数、拷贝构造函数、拷贝赋值运算符以及移动构造函数、移动赋值运算符都应该显式调用基类的相关函数，传入复制／移动对象即可，因为基类的这些函数参数一定是个引用，基类可以引用派生类。而析构函数则不需要，只释放自己的资源就好。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;如果在构造或析构函数中调用了虚函数，调用的是当前函数对应类的虚函数版本，不会调用派生类的版本，因为此时派生类部分还没有初始化活着已经析构了，不存在（换句话说，此时虚表中不存在派生类的信息）。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;iostream&amp;gt;
using namespace std;
class base{
public:
    base(){vfunc();}
    virtual void vfunc(){cout&amp;lt;&amp;lt;&amp;quot;base n: &amp;quot;&amp;lt;&amp;lt;n&amp;lt;&amp;lt;endl;}
    virtual ~base(){cout&amp;lt;&amp;lt;&amp;quot;d base &amp;quot;;vfunc();}
private:
    int n=0;
};
class d1:public base{
public:
    d1(){vfunc();}
    void vfunc(){cout&amp;lt;&amp;lt;&amp;quot;d1 x: &amp;quot;&amp;lt;&amp;lt;x&amp;lt;&amp;lt;endl;}
    ~d1(){cout&amp;lt;&amp;lt;&amp;quot;d d1&amp;quot;;vfunc();}
private:
    int x=1;
};
int main(){
    // d1 d;
    base *bp=new d1;
    delete bp;
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ ./dcvirtual.out
base n: 0
d1 x: 1
d d1d1 x: 1
d base base n: 0
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;因为向一个基类赋值派生类会产生“截断”现象（因为调用的是基类的拷贝函数），所以不要在容器中直接存储基类对象，这样一旦你向其中放入派生类，就会截断，切编译器不会报错。应在容器中存储基类指针。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>cpp primer 第十四章笔记</title>
      <link>http://shamaoxiaogui.github.io/post/cpp_primer_note_14/</link>
      <pubDate>Thu, 21 Jul 2016 09:18:59 +0800</pubDate>
      
      <guid>http://shamaoxiaogui.github.io/post/cpp_primer_note_14/</guid>
      <description>&lt;p&gt;第十四章主要讲运算符重载和类型转换（感觉每次第一句话都是废话）：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;不应该被重载的运算符：&lt;code&gt;&amp;amp;&amp;amp; || ,&lt;/code&gt;因为无法保留其运算顺序（还有逻辑运算符的短路运算属性），而对于逗号和取址运算，语言已经定义了其对于类的特殊含义&lt;/li&gt;
&lt;li&gt;必须定义为成员函数的运算符：&lt;code&gt;= [] () -&amp;gt;&lt;/code&gt;（语言也禁止这样做）&lt;/li&gt;
&lt;li&gt;对于需要对称性的运算符（＋），可能会转换任一端参数，定义为普通函数&lt;/li&gt;
&lt;li&gt;对于输入输出运算符的重载，注意：

&lt;ol&gt;
&lt;li&gt;减少格式化输出，不应该添加换行符&lt;/li&gt;
&lt;li&gt;输入输出运算符必须是非成员函数&lt;/li&gt;
&lt;li&gt;输入运算符中应处理出错情况，负责从错误中恢复；输出运算符则不需要考虑错误&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;同时定义了算术运算符和相关的复合赋值运算，应优先使用复合赋值（开销小）&lt;/li&gt;

&lt;li&gt;&lt;p&gt;递增递减运算的原型：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class X{
public:
    X&amp;amp; operator++();    //前置
    X operator++(int);  //后置，其中参数不会用到
};
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;下表运算一般定义两个版本，普通的返回引用，加const限定符的返回常量引用&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;lambda表达式产生的类不含默认构造函数、赋值运算符、默认析构函数&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;cpp的可调用对象有：函数、函数指针、lambda表达式、bind对象、函数对象&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;std::function模版可以用来存放或者说是接受可调用对象，但是不能放重载函数，解决方案是使用函数指针活着lambda给重载函数做一个“别名”。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;类型转换函数，可以定义为转换成任何能作为函数返回类型的类型（数组、函数类型就不行，但是数组指针和函数指针可以）；必须是类的成员函数；无返回类型参数列表；通常const限定：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;operator type() const;
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;显示的类型转换运算符，就是在前面加explicit，使用时必须用cast。例外：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;if，while，do语句条件部分&lt;/li&gt;
&lt;li&gt;for语句条件部分&lt;/li&gt;
&lt;li&gt;&lt;code&gt;! || &amp;amp;&amp;amp;&lt;/code&gt;运算对象&lt;/li&gt;
&lt;li&gt;条件运算符表达式（?:）的条件部分&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;这些语句中会隐式的调用显示类型转换运算符中转换为bool的那类。比如io库中，我们经常用：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;while(cin&amp;gt;&amp;gt;n){
...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;所以，一般向bool型的类型转换我们可以大胆的写成explicit的（一般也只定义向bool的转换）&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>cpp primer 第十三章笔记</title>
      <link>http://shamaoxiaogui.github.io/post/cpp_primer_note_13/</link>
      <pubDate>Wed, 20 Jul 2016 21:40:45 +0800</pubDate>
      
      <guid>http://shamaoxiaogui.github.io/post/cpp_primer_note_13/</guid>
      <description>&lt;p&gt;嘿嘿，飙到第十三章了～～老司机的笑容像天上的弦月～～毕竟是补漏。。。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;拷贝构造函数通常不应该是explicit的，参数必须为引用类型（常量引用）&lt;/li&gt;
&lt;li&gt;合成的拷贝构造函数对于数组成员会逐一拷贝其元素&lt;/li&gt;
&lt;li&gt;编译器有时会绕过拷贝构造函数（优化为直接构造）&lt;/li&gt;
&lt;li&gt;三／五法则：析构函数，拷贝构造函数，拷贝赋值运算符，移动构造函数，移动赋值运算符，可以看成一个整体，通常需要定义其中一个也就意味着需要定义其余四个。&lt;/li&gt;
&lt;li&gt;新司机还记得&lt;code&gt;=default&lt;/code&gt;不？&lt;/li&gt;
&lt;li&gt;阻止拷贝：旧标准可以把相关构造函数&lt;strong&gt;&lt;em&gt;声明&lt;/em&gt;&lt;/strong&gt;为private，不需要定义；新标准可以用&lt;code&gt;=delete&lt;/code&gt;。当不能拷贝、赋值或销毁类的成员时，类的合成拷贝控制成员就被定义为删除的&lt;/li&gt;
&lt;li&gt;对于一个赋值运算符，编写时需要考虑：

&lt;ol&gt;
&lt;li&gt;一个对象赋值给它自身，要工作正常（所以要在析构当前对象前保存“新”对象）&lt;/li&gt;
&lt;li&gt;拷贝＋析构&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;如果swap操作不会拷贝对象而只是交换指针（通常都是如此），那么可以利用“拷贝并交换”技术来编写赋值运算：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;tc&amp;amp; operator=(tc rhs){  //传值复制了rhs
    swap(*this,rhs);    
    return *this;
}   //rhs也就是原来的本对象会自动析构
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;左值引用不能绑定到&lt;strong&gt;&lt;em&gt;要求转换的表达式、字面常量、返回右值的表达式&lt;/em&gt;&lt;/strong&gt;，但是常量左值引用可以哦，而右值引用则和左值引用完成相反&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;int i=10;
double &amp;amp;rd=i;   //error
int &amp;amp;ri=30;     //error
int &amp;amp;rri=i+3;   //error
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;右值短暂，都是临时对象，左值持久。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;右值和右值引用是不一样的，简单的说，右值就是临时量，不是变量，而右值引用是引用右值的变量，是个变量，它通过引用右值（临时量）将临时量变为变量，本来临时量马上就会消亡，你一用右值引用引用它，就把它变成一个持久的变量了，所以primer说，右值引用从绑定到其的临时量中“窃取”状态。同样的，右值引用是一个变量不是临时量，所以右值引用不能绑定右值引用（绕口。。。），还有，右值意味着它只有你这个所有者，你可以为所欲为（修改它）&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;使用&lt;code&gt;std::move&lt;/code&gt;可以将一个左值转换为右值引用，也就是告诉编译器，这个左值劳资要当成右值用，你放心，过会儿劳资就削了它！（也就是说除了销魂不能对它再做任何操作，起始还可以再赋值给他，但是不能直接使用它的值。。。）
1.
移动构造函数和移动赋值运算符，参数都是非const的右值引用，调用后移后对象应处于可析构状态（意思是说，假设把a移动给b，就算你在调用移动构造函数之后把a析构了，也不会影响到b的内容，主要是考虑指针的处理），再者二者不应该抛出异常，使用noexcept关键字（编译器看到这个关键字的话，在这个函数抛出异常时，会直接调用terminate()，同时，它也告诉标准库容器该类的移动构造函数不会抛出异常，否则，标准库会因为预防发生异常的时候需要恢复原状而使用拷贝语义）。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;拷贝左值，移动右值，没有移动就只能拷贝右值&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;标准库的重载函数往往有两个版本：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;void push_back(const X&amp;amp;);   //copy
void push_back(X&amp;amp;&amp;amp;);    //move
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;拷贝操作对参数应该没有影响，故而必然是const的，而移动操作会对移后对象进行操作，所以必然是非const的&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;可以在成员函数后面活着重载运算符后面加引用限定符表示this指向的对象只能是左值或者右值&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class foo{
public:
    foo&amp;amp; operator=(const foo&amp;amp;) &amp;amp;;   //只有左值才能使用＝
    void somefunc() &amp;amp;&amp;amp;;     //只有右值才能使用该函数
    void hehe() const &amp;amp;;    //只有const左值才能使用该函数，const必须在前
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;至于重载函数，const限定符的成员函数和同名同参的普通成员函数构成重载，而不同引用限定符的同名同参成员函数之间也构成重载，重载的对象就是类本身是左值还是右值。另外，一旦在const限定符与普通重载函数之间的任何一个上用了引用限定符，那这一组重载函数中就都得用引用限定符了；&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>cpp primer 第七章笔记</title>
      <link>http://shamaoxiaogui.github.io/post/cpp_primer_note_7/</link>
      <pubDate>Wed, 20 Jul 2016 16:36:02 +0800</pubDate>
      
      <guid>http://shamaoxiaogui.github.io/post/cpp_primer_note_7/</guid>
      <description>&lt;p&gt;第七章，终于到正题了，类：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;只有在类中没有任何构造函数时，编译器才会生产合成默认构造函数；只有当类内部的内置类型被赋予类内初始值时，合成默认构造函数才有可能合适；如果类内包含其它的没有默认构造函数的类时，编译器不能为其生成合成默认构造函数；可以明确指定使用合成默认构造函数：&lt;code&gt;xxx()=default;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;继承的三种方式，参见&lt;a href=&#34;http://blog.csdn.net/complety/article/details/7493194&#34;&gt;文章&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;友元也会被继承，但是友元类不具有传递性；友元声明仅仅是友元声明，一般需要在类定义外加一个普通函数声明（一般类定义是放在头文件的，所以一般也需要这个普通函数声明），虽然有的编译器不这么要求&lt;/li&gt;
&lt;li&gt;mutable关键字是说，即使类的实体是个const实体，其mutable成员也是可以改变的&lt;/li&gt;
&lt;li&gt;类内初始值可以用＝和花括号&lt;/li&gt;
&lt;li&gt;对于类中的const、引用或者未提供默认构造函数的类成员，必须用类内初始值或者构造函数的初始值列表来初始化，而不能直接在构造函数中“初始化”（原因很简单，构造函数中的“初始化”实际上是先对成员进行默认初始化，然后赋值，上面这三种都不能默认初始化）&lt;/li&gt;

&lt;li&gt;&lt;p&gt;关于构造顺序，我们可以做个实验：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;string&amp;gt;
using std::string;
using std::cout;
using std::endl;
class member{
public:
    member(int n):m(n){cout&amp;lt;&amp;lt;&amp;quot;member &amp;quot;&amp;lt;&amp;lt;m&amp;lt;&amp;lt;&amp;quot; ctor&amp;quot;&amp;lt;&amp;lt;endl;}
    ~member(){cout&amp;lt;&amp;lt;&amp;quot;member &amp;quot;&amp;lt;&amp;lt;m&amp;lt;&amp;lt;&amp;quot; dctor&amp;quot;&amp;lt;&amp;lt;endl;}
private:
    int m; 
};
class grandpa{
public:
    grandpa(const string&amp;amp; n=&amp;quot;G&amp;quot;):name(n){cout&amp;lt;&amp;lt;&amp;quot;grand &amp;quot;&amp;lt;&amp;lt;name&amp;lt;&amp;lt;&amp;quot; ctor&amp;quot;&amp;lt;&amp;lt;endl;}
    ~grandpa(){cout&amp;lt;&amp;lt;&amp;quot;grand &amp;quot;&amp;lt;&amp;lt;name&amp;lt;&amp;lt;&amp;quot; dctor&amp;quot;&amp;lt;&amp;lt;endl;}
private:
    string name;
};
class father:public grandpa{
public:
    father(const string&amp;amp; n=&amp;quot;F&amp;quot;):name(n){cout&amp;lt;&amp;lt;&amp;quot;father &amp;quot;&amp;lt;&amp;lt;name&amp;lt;&amp;lt;&amp;quot; ctor&amp;quot;&amp;lt;&amp;lt;endl;}
    ~father(){cout&amp;lt;&amp;lt;&amp;quot;father &amp;quot;&amp;lt;&amp;lt;name&amp;lt;&amp;lt;&amp;quot; dctor&amp;quot;&amp;lt;&amp;lt;endl;}
private:
    string name;
};
class child:public father{
public:
    child(const string&amp;amp; n=&amp;quot;C&amp;quot;):m1(1),m2(2),m3(3),name(n){cout&amp;lt;&amp;lt;&amp;quot;child &amp;quot;&amp;lt;&amp;lt;name&amp;lt;&amp;lt;&amp;quot; ctor&amp;quot;&amp;lt;&amp;lt;endl;}
    ~child(){cout&amp;lt;&amp;lt;&amp;quot;child &amp;quot;&amp;lt;&amp;lt;name&amp;lt;&amp;lt;&amp;quot; dctor&amp;quot;&amp;lt;&amp;lt;endl;}
private:
    string name;
    static member m4;
    member m1,m2,m3;
};
member child::m4(4);
int main(){
    child ch;
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ ./initorder.out
member 4 ctor
grand G ctor
father F ctor
member 1 ctor
member 2 ctor
member 3 ctor
child C ctor
child C dctor
member 3 dctor
member 2 dctor
member 1 dctor
father F dctor
grand G dctor
member 4 dctor
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;总结一下：首先，类的静态变量和程序的全局变量一起初始化，然后类的父类初始化，然后类自身初始化，其中成员按照定义的顺序初始化，最后执行类自身的构造函数。析构的时候，完全反过来：先调用自己的析构，然后逆着成员的定义顺序析构成员，最后调用父类的析构函数。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;委托构造函数，嗯，好东西，有了这个就不需要之前的init辅助函数&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;explicit禁止隐式转换，切不能当成拷贝初始化，但可以用构造函数显示转换为临时对象，或者static_cast也可以&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;聚合类的条件：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;所有成员public&lt;/li&gt;
&lt;li&gt;没定义任何构造函数&lt;/li&gt;
&lt;li&gt;没有类内初始值&lt;/li&gt;
&lt;li&gt;没有基类，没有虚函数&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>cpp primer 第六章笔记</title>
      <link>http://shamaoxiaogui.github.io/post/cpp_primer_note_6/</link>
      <pubDate>Wed, 20 Jul 2016 14:49:08 +0800</pubDate>
      
      <guid>http://shamaoxiaogui.github.io/post/cpp_primer_note_6/</guid>
      <description>&lt;p&gt;第六章主要是函数相关的内容：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;函数是可以没有定义只有声明的，只要你不用它（变量声明，类的前置声明也是）。。。&lt;/li&gt;
&lt;li&gt;关于引用与指针，我觉得最重要的区别的话，主要是

&lt;ol&gt;
&lt;li&gt;引用初始化后就不能再改变引用的对象了，而指针可以指向不同的对象&lt;/li&gt;
&lt;li&gt;有空指针没有空引用&lt;/li&gt;
&lt;li&gt;引用是对象的别名，不是一个对象，而指针是一个专门用来存放地址的对象，所以sizeof二者会有区别&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;对于函数的参数，可以理解为c++只有传值，没有传引用，其传引用是通过对地址的传值实现的。数组传引用时会退化成指针，当使用引用来作为数组形参时，需要指定维度，不符合维度的数组不能匹配到该函数&lt;/li&gt;
&lt;li&gt;又到了可爱的initializer_list，记住注意复制开销&lt;/li&gt;
&lt;li&gt;关于函数return临时对象的问题，参见&lt;a href=&#34;http://www.cnblogs.com/xkfz007/articles/2506022.html&#34;&gt;文章&lt;/a&gt;，可见编译器帮我们做了很多事情，但是仍然注意后面的右值引用和完美转发&lt;/li&gt;
&lt;li&gt;inline和constexpr函数可以定义多次，但是定义必须完全一样，所以一般把它们放到头文件中&lt;/li&gt;

&lt;li&gt;&lt;p&gt;对于函数对象和函数的比较，发现效率似乎差距不大（clang）&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;chrono&amp;gt;
auto func1(int t)-&amp;gt;int{
    return ++t;
}
class func2{
public:
    auto operator()(int t)-&amp;gt;int{
        return ++t;
    }
};
inline int func3(int t){
    return ++t;
}
static inline int func4(int t){
    return ++t;
}
int main(){
    int n,i=0;
    std::chrono::high_resolution_clock::time_point t1,t2;
    std::cout&amp;lt;&amp;lt;&amp;quot;input: &amp;quot;;
    std::cin&amp;gt;&amp;gt;n;
    std::cout&amp;lt;&amp;lt;std::endl;
    std::cout&amp;lt;&amp;lt;&amp;quot;=========================&amp;quot;&amp;lt;&amp;lt;std::endl;
    t1=std::chrono::high_resolution_clock::now();
    for(int j=0;j&amp;lt;n;++j){
        i=func1(j);
    }
    t2=std::chrono::high_resolution_clock::now();
    std::cout&amp;lt;&amp;lt;&amp;quot;time: &amp;quot;&amp;lt;&amp;lt;std::chrono::duration_cast&amp;lt;std::chrono::microseconds&amp;gt;(t2-t1).count()&amp;lt;&amp;lt;&amp;quot; microseconds&amp;quot;&amp;lt;&amp;lt;std::endl;
    std::cout&amp;lt;&amp;lt;&amp;quot;=========================&amp;quot;&amp;lt;&amp;lt;std::endl;
    func2 func2i;
    t1=std::chrono::high_resolution_clock::now();
    for(int j=0;j&amp;lt;n;++j){
        i=func2i(j);
    }
    t2=std::chrono::high_resolution_clock::now();
    std::cout&amp;lt;&amp;lt;&amp;quot;time: &amp;quot;&amp;lt;&amp;lt;std::chrono::duration_cast&amp;lt;std::chrono::microseconds&amp;gt;(t2-t1).count()&amp;lt;&amp;lt;&amp;quot; microseconds&amp;quot;&amp;lt;&amp;lt;std::endl;
    std::cout&amp;lt;&amp;lt;&amp;quot;=========================&amp;quot;&amp;lt;&amp;lt;std::endl;
    t1=std::chrono::high_resolution_clock::now();
    for(int j=0;j&amp;lt;n;++j){
        i=func3(j);
    }
    t2=std::chrono::high_resolution_clock::now();
    std::cout&amp;lt;&amp;lt;&amp;quot;time: &amp;quot;&amp;lt;&amp;lt;std::chrono::duration_cast&amp;lt;std::chrono::microseconds&amp;gt;(t2-t1).count()&amp;lt;&amp;lt;&amp;quot; microseconds&amp;quot;&amp;lt;&amp;lt;std::endl;
    std::cout&amp;lt;&amp;lt;&amp;quot;=========================&amp;quot;&amp;lt;&amp;lt;std::endl;
    t1=std::chrono::high_resolution_clock::now();
    for(int j=0;j&amp;lt;n;++j){
        i=func4(j);
    }
    t2=std::chrono::high_resolution_clock::now();
    std::cout&amp;lt;&amp;lt;&amp;quot;time: &amp;quot;&amp;lt;&amp;lt;std::chrono::duration_cast&amp;lt;std::chrono::microseconds&amp;gt;(t2-t1).count()&amp;lt;&amp;lt;&amp;quot; microseconds&amp;quot;&amp;lt;&amp;lt;std::endl;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ ./functest.out
input: 1000000000

=========================
time: 3859925 microseconds
=========================
time: 3849522 microseconds
=========================
time: 3647694 microseconds
=========================
time: 3865106 microseconds
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>cpp primer 第五章笔记</title>
      <link>http://shamaoxiaogui.github.io/post/cpp_primer_note_5/</link>
      <pubDate>Wed, 20 Jul 2016 13:59:57 +0800</pubDate>
      
      <guid>http://shamaoxiaogui.github.io/post/cpp_primer_note_5/</guid>
      <description>&lt;p&gt;第五章讲解语句：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;注意switch内部块中定义的变量，尽管在同一个作用域中（case后面不跟大括号的情况），但是只要是没有初始化的变量就不能使用，比如&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;switch(ch){
case &#39;a&#39;:
    string name;    //错误，可能绕开隐式初始化
    int a=0;    //错误，可能绕开显示初始化
    int b;  //正确，未初始化，可以在其他控制块中初始化
    break;
case &#39;b&#39;:
    b=1;    //正确，赋值
    if(name.empty())    //错误，虽然在作用域内，但没有初始化
    //...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;简单有效的做法是，限定作用域，即在case后使用大括号&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;关于异常，这里引用陈硕在知乎上的回答：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;作者：陈硕
链接：&lt;a href=&#34;http://www.zhihu.com/question/22889420/answer/22975569&#34;&gt;http://www.zhihu.com/question/22889420/answer/22975569&lt;/a&gt;
来源：知乎
著作权归作者所有，转载请联系作者获得授权。&lt;/p&gt;

&lt;p&gt;整个 C++ exception 的行为在常见语言中是最奇葩的， 因为这个语言特性与 C++ 其他 feature（特别是确定性析构） 格格不入。在 C++ 中全面铺开使用异常会遇到其他语言中不存在的问题。&lt;/p&gt;

&lt;p&gt;从网上容易找到一些公司/组织的C++编码规范，其中至少 Google、Mozilla、Qt、LLVM 这几家的规范是明确禁用异常的。前面三家或许可以用代码历史包袱、程序员C++水平参差不齐、保证可移植性等理由来解释，但是 LLVM 却不同。首先，LLVM 在 2003 年才发布第一版，是个21世纪的新项目，没什么历史包袱；更重要的是，LLVM 的作者同时也开发了 clang 这个 C++ 编译器，用 C++ 写 C++ 编译器的程序员恐怕是 C++ 程序员里对语言掌握得最好的那一批，如果他们都在项目中明确地禁用异常，这意味着什么呢？注意到 clang 源码已经用上了 C++11，那么“考虑移植性照顾老host编译器”这条理由似乎也不成立了。&lt;/p&gt;

&lt;p&gt;C++ 引入异常的原因之一是为了能让构造函数报错（析构函数不能抛异常这是大家都知道的常识），毕竟构造函数没有返回值，没有异常的话调用方如何得知对象构造是否成功呢？但是编译器/标准库为了让构造函数能抛异常却是麻烦重重：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;数组元素构造时抛异常，前面已经构造好的元素要析构，还没有构造的元素不能析构。&lt;/li&gt;
&lt;li&gt;构造函数的初始化列表里抛异常，前面已经构造好的成员和基类子对象要析构，还没有构造的成员则不能析构。而且这个异常捕获之后必须重新抛出（编译器强制），因为C++不允许“半吊子”构造的对象存在。&lt;/li&gt;
&lt;li&gt;多继承中某个基类的构造函数抛异常，那么已经构造好的基类子对象要析构，还没有构造的基类子对象则不能析构。虚拟继承，虚基类只能析构一次，你慢慢想吧。&lt;/li&gt;
&lt;li&gt;函数实参对象构造时抛异常，那么多个实参中已经构造好的实参对象要析构，尚未构造的实参对象不能析构。&lt;/li&gt;
&lt;li&gt;std::vector 在 resizing 的时候某个元素的拷贝发生异常，那么前面已经拷贝的元素要析构，尚未拷贝的元素则不必也不能析构，去看 gcc vector::_M_insert_aux 的代码有多麻烦。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;（注脚：C++ 引入异常的另一个原因是让 dynamic_cast&lt;Derived&amp;&gt;(baseReference) 能报错，因为没有 null reference。还有一个原因是让 overloaded operator 能报错，毕竟 operator 的返回类型往往无法包含 error code，例如 operator=() 返回的是 Type&amp;amp;。C++ 也是唯一一个变量赋值有可能会抛异常的语言，例如 Person s; s = getPersonById(someId);，那么即便 getPersonById() 不抛异常也不能保证上一句赋值不抛异常。）&lt;/p&gt;

&lt;p&gt;（注脚2：C++ 引入异常的政治原因是 Ada 支持异常，而 Ada 是 DoD 的指定官方语言，如果 C++ 不支持异常，那么 AT&amp;amp;T 贝尔实验室就不能拿 C++ 做 DoD 的项目。）&lt;/p&gt;

&lt;p&gt;C++ 编译器要随时提防调用某个函数 foo 会抛异常，这会阻止一些优化，也会产生很多累赘的代码（随时准备析构那些调用 foo 函数前已经构造好的栈上对象）。因此 C++11 的 noexcept 应该大力推广。&lt;/p&gt;

&lt;p&gt;C++ 的 exception specification 也很鸡肋，它不像 Java 那样在编译期检查（Java 似乎也流行使用 unchecked exception 了），而是在运行期检查，而且违反的后果是直接终止程序，那谁敢用啊？还不如用代码注释呢。有的编译器干脆就只支持语法而不实现功能（Exception Specifications）。C# 也不支持 exception specification，可见这是一项无用的语言特性，算是编程语言发展历史上走的弯路吧，可惜 Java/C++ 掉坑里了。&lt;/p&gt;

&lt;p&gt;其他支持异常的语言几乎都有 GC，抛异常就抛了，不用担心析构，反正GC管着。只有 C++ 才有 exception safety 需要考虑，其他支持异常的语言都没有这一概念。&lt;/p&gt;

&lt;p&gt;而且 Java 的 try-with-resource，C# 的 using，Python 的 with 在管理 function local scope 对象的生命期（资源、lock 释放）方面不比 RAII 麻烦。Go defer 要差一些，它是 function 级，不是 block 级，只能对付 return。 不过反正 Go 也没异常，有点小坑罢了，把函数写短点就能绕过。&lt;/p&gt;

&lt;p&gt;RAII 的优势在于将对象的生命期管理与其他资源（锁、文件、网络连接等等）的管理整合，然后通过 smart pointers 一并解决了，这是 C++ 独一无二的优势。&lt;/p&gt;

&lt;p&gt;如果写递归下降的 parser，那么内部用异常来报错似乎是合理的，对外返回一个 error code 即可。&lt;/p&gt;
&lt;/blockquote&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;总之，呵呵～～&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>cpp primer 第四章笔记</title>
      <link>http://shamaoxiaogui.github.io/post/cpp_primer_note_4/</link>
      <pubDate>Tue, 19 Jul 2016 21:18:38 +0800</pubDate>
      
      <guid>http://shamaoxiaogui.github.io/post/cpp_primer_note_4/</guid>
      <description>&lt;p&gt;第四章主要是表达式相关的内容：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;除了&lt;code&gt;&amp;amp;&amp;amp; || ?: ,&lt;/code&gt;四种操作符外，其他操作符都没有定义运算顺序（重要）&lt;/li&gt;

&lt;li&gt;&lt;p&gt;sizeof是一种运算符，它不会对表达式进行求值，c++11允许用作用域运算符(::)来获取成员大小而不必提供一个实体（前提是，该成员是public的，活着调用方法是static的），对数组返回数组大小而不是指针大小，对vector和string这种返回其固定部分大小。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;string&amp;gt;
class testc{
public:
    char pwc;
    void update(){}
private:
    char wc;
};
int main(){
    int a=44;
    int ar[5];
    std::string str(&amp;quot;heheda!&amp;quot;);
    std::cout&amp;lt;&amp;lt;&amp;quot;int : &amp;quot;&amp;lt;&amp;lt;sizeof(a)&amp;lt;&amp;lt;&amp;quot; &amp;quot;&amp;lt;&amp;lt;sizeof(int)&amp;lt;&amp;lt;std::endl;
    std::cout&amp;lt;&amp;lt;&amp;quot;int [5]: &amp;quot;&amp;lt;&amp;lt;sizeof(ar)&amp;lt;&amp;lt;&amp;quot; &amp;quot;&amp;lt;&amp;lt;sizeof(int [5])&amp;lt;&amp;lt;std::endl;
    std::cout&amp;lt;&amp;lt;&amp;quot;string :&amp;quot;&amp;lt;&amp;lt;sizeof(str)&amp;lt;&amp;lt;&amp;quot; &amp;quot;&amp;lt;&amp;lt;sizeof(std::string)&amp;lt;&amp;lt;std::endl;
    std::cout&amp;lt;&amp;lt;&amp;quot;class member(char): &amp;quot;&amp;lt;&amp;lt;sizeof(testc::pwc)&amp;lt;&amp;lt;std::endl;
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ ./sizeoftest.out
int : 4 4
int [5]: 20 20
string :24 24
class member(char): 1
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;逗号运算符先算左边再算右边，最后返回右边，若右边结果为左值则返回的也是左值&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;大多数情况下数组退化为指针，有四种例外：decltype、取址运算符（&amp;amp;），sizeof，typeid：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;iostream&amp;gt;
int main(){
    int a[4];
    std::cout&amp;lt;&amp;lt;&amp;quot;int size: &amp;quot;&amp;lt;&amp;lt;sizeof(int)&amp;lt;&amp;lt;std::endl;
    std::cout&amp;lt;&amp;lt;&amp;quot;arr size: &amp;quot;&amp;lt;&amp;lt;sizeof(a)&amp;lt;&amp;lt;std::endl;
    std::cout&amp;lt;&amp;lt;&amp;quot;a[0] addr: &amp;quot;&amp;lt;&amp;lt;&amp;amp;a[0]&amp;lt;&amp;lt;std::endl;
    std::cout&amp;lt;&amp;lt;&amp;quot;a addr: &amp;quot;&amp;lt;&amp;lt;a&amp;lt;&amp;lt;std::endl;
    std::cout&amp;lt;&amp;lt;&amp;quot;&amp;amp;a :&amp;quot;&amp;lt;&amp;lt;&amp;amp;a&amp;lt;&amp;lt;std::endl;
    std::cout&amp;lt;&amp;lt;&amp;quot;&amp;amp;a[0]+1: &amp;quot;&amp;lt;&amp;lt;&amp;amp;a[0]+1&amp;lt;&amp;lt;std::endl;
    std::cout&amp;lt;&amp;lt;&amp;quot;a+1: &amp;quot;&amp;lt;&amp;lt;a+1&amp;lt;&amp;lt;std::endl;
    std::cout&amp;lt;&amp;lt;&amp;quot;&amp;amp;a+1: &amp;quot;&amp;lt;&amp;lt;&amp;amp;a+1&amp;lt;&amp;lt;std::endl;
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ ./arrayaddr.out
int size: 4
arr size: 16
a[0] addr: 0x7fff566947e0
a addr: 0x7fff566947e0
&amp;amp;a :0x7fff566947e0
&amp;amp;a[0]+1: 0x7fff566947e4
a+1: 0x7fff566947e4
&amp;amp;a+1: 0x7fff566947f0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以发现当采取&lt;code&gt;&amp;amp;a+1&lt;/code&gt;这种形式时，与数组首地址相比，并不是单纯加4，而是加4*4，故而大胆推测，&lt;code&gt;&amp;amp;a&lt;/code&gt;的类型为&lt;code&gt;int [4]&lt;/code&gt;（类似二维数组中的一维元素）&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;指针的转换规则：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;0和nullptr可以转换成任意指针（空指针）&lt;/li&gt;
&lt;li&gt;任意非常量指针可以转换成&lt;code&gt;void*&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;任意指针可以转换成&lt;code&gt;const void*&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;显示转换：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;static_cast&lt;/code&gt;就相当于c的强制类型转换&lt;/li&gt;
&lt;li&gt;&lt;code&gt;const_cast&lt;/code&gt;去除底层const属性，但是对转换后的对象（一般是指针，对其指向的对象）写操作是未定义的，而且不能改变变量类型&lt;/li&gt;
&lt;li&gt;&lt;code&gt;reinterpret_cast&lt;/code&gt;最危险的转换，相当于对同一个内存的地址做不同意义的解释（比如把一个int＊解释为一个char＊），依赖于机器&lt;/li&gt;
&lt;li&gt;&lt;code&gt;dynamic_cast&lt;/code&gt;将指向子类的父类型的指针转化为子类型，这个功能也可以由&lt;code&gt;static_cast&lt;/code&gt;来实现，但是dy会在运行时检查父子类关系，而static只会在编译时检查&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
  </channel>
</rss>