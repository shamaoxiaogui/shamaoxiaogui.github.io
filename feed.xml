<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Adro的作死笔记</title>
    <link>http://shamaoxiaogui.github.io/</link>
    <description>Recent content on Adro的作死笔记</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <lastBuildDate>Tue, 19 Jul 2016 21:18:38 +0800</lastBuildDate>
    <atom:link href="http://shamaoxiaogui.github.io/feed/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>cpp primer 第四章笔记</title>
      <link>http://shamaoxiaogui.github.io/post/cpp_primer_note_4/</link>
      <pubDate>Tue, 19 Jul 2016 21:18:38 +0800</pubDate>
      
      <guid>http://shamaoxiaogui.github.io/post/cpp_primer_note_4/</guid>
      <description>&lt;p&gt;第四章主要是表达式相关的内容：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;除了&lt;code&gt;&amp;amp;&amp;amp; || ?: ,&lt;/code&gt;四种操作符外，其他操作符都没有定义运算顺序（重要）&lt;/li&gt;

&lt;li&gt;&lt;p&gt;sizeof是一种运算符，它不会对表达式进行求值，c++11允许用作用域运算符(::)来获取成员大小而不必提供一个实体（前提是，该成员是public的，活着调用方法是static的），对数组返回数组大小而不是指针大小，对vector和string这种返回其固定部分大小。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;string&amp;gt;
class testc{
public:
    char pwc;
    void update(){}
private:
    char wc;
};
int main(){
    int a=44;
    int ar[5];
    std::string str(&amp;quot;heheda!&amp;quot;);
    std::cout&amp;lt;&amp;lt;&amp;quot;int : &amp;quot;&amp;lt;&amp;lt;sizeof(a)&amp;lt;&amp;lt;&amp;quot; &amp;quot;&amp;lt;&amp;lt;sizeof(int)&amp;lt;&amp;lt;std::endl;
    std::cout&amp;lt;&amp;lt;&amp;quot;int [5]: &amp;quot;&amp;lt;&amp;lt;sizeof(ar)&amp;lt;&amp;lt;&amp;quot; &amp;quot;&amp;lt;&amp;lt;sizeof(int [5])&amp;lt;&amp;lt;std::endl;
    std::cout&amp;lt;&amp;lt;&amp;quot;string :&amp;quot;&amp;lt;&amp;lt;sizeof(str)&amp;lt;&amp;lt;&amp;quot; &amp;quot;&amp;lt;&amp;lt;sizeof(std::string)&amp;lt;&amp;lt;std::endl;
    std::cout&amp;lt;&amp;lt;&amp;quot;class member(char): &amp;quot;&amp;lt;&amp;lt;sizeof(testc::pwc)&amp;lt;&amp;lt;std::endl;
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ ./sizeoftest.out
int : 4 4
int [5]: 20 20
string :24 24
class member(char): 1
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;逗号运算符先算左边再算右边，最后返回右边，若右边结果为左值则返回的也是左值&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;大多数情况下数组退化为指针，有四种例外：decltype、取址运算符（&amp;amp;），sizeof，typeid：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;iostream&amp;gt;
int main(){
    int a[4];
    std::cout&amp;lt;&amp;lt;&amp;quot;int size: &amp;quot;&amp;lt;&amp;lt;sizeof(int)&amp;lt;&amp;lt;std::endl;
    std::cout&amp;lt;&amp;lt;&amp;quot;arr size: &amp;quot;&amp;lt;&amp;lt;sizeof(a)&amp;lt;&amp;lt;std::endl;
    std::cout&amp;lt;&amp;lt;&amp;quot;a[0] addr: &amp;quot;&amp;lt;&amp;lt;&amp;amp;a[0]&amp;lt;&amp;lt;std::endl;
    std::cout&amp;lt;&amp;lt;&amp;quot;a addr: &amp;quot;&amp;lt;&amp;lt;a&amp;lt;&amp;lt;std::endl;
    std::cout&amp;lt;&amp;lt;&amp;quot;&amp;amp;a :&amp;quot;&amp;lt;&amp;lt;&amp;amp;a&amp;lt;&amp;lt;std::endl;
    std::cout&amp;lt;&amp;lt;&amp;quot;&amp;amp;a[0]+1: &amp;quot;&amp;lt;&amp;lt;&amp;amp;a[0]+1&amp;lt;&amp;lt;std::endl;
    std::cout&amp;lt;&amp;lt;&amp;quot;a+1: &amp;quot;&amp;lt;&amp;lt;a+1&amp;lt;&amp;lt;std::endl;
    std::cout&amp;lt;&amp;lt;&amp;quot;&amp;amp;a+1: &amp;quot;&amp;lt;&amp;lt;&amp;amp;a+1&amp;lt;&amp;lt;std::endl;
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ ./arrayaddr.out
int size: 4
arr size: 16
a[0] addr: 0x7fff566947e0
a addr: 0x7fff566947e0
&amp;amp;a :0x7fff566947e0
&amp;amp;a[0]+1: 0x7fff566947e4
a+1: 0x7fff566947e4
&amp;amp;a+1: 0x7fff566947f0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以发现当采取&lt;code&gt;&amp;amp;a+1&lt;/code&gt;这种形式时，与数组首地址相比，并不是单纯加4，而是加4*4，故而大胆推测，&lt;code&gt;&amp;amp;a&lt;/code&gt;的类型为&lt;code&gt;int [4]&lt;/code&gt;（类似二维数组中的一维元素）&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;指针的转换规则：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;0和nullptr可以转换成任意指针（空指针）&lt;/li&gt;
&lt;li&gt;任意非常量指针可以转换成&lt;code&gt;void*&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;任意指针可以转换成&lt;code&gt;const void*&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;显示转换：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;static_cast&lt;/code&gt;就相当于c的强制类型转换&lt;/li&gt;
&lt;li&gt;&lt;code&gt;const_cast&lt;/code&gt;去除底层const属性，但是对转换后的对象（一般是指针，对其指向的对象）写操作是未定义的，而且不能改变变量类型&lt;/li&gt;
&lt;li&gt;&lt;code&gt;reinterpret_cast&lt;/code&gt;最危险的转换，相当于对同一个内存的地址做不同意义的解释（比如把一个int＊解释为一个char＊），依赖于机器&lt;/li&gt;
&lt;li&gt;&lt;code&gt;dynamic_cast&lt;/code&gt;将指向子类的父类型的指针转化为子类型，这个功能也可以由&lt;code&gt;static_cast&lt;/code&gt;来实现，但是dy会在运行时检查父子类关系，而static只会在编译时检查&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>cpp primer 第三章笔记</title>
      <link>http://shamaoxiaogui.github.io/post/cpp_primer_note_3/</link>
      <pubDate>Tue, 19 Jul 2016 17:05:39 +0800</pubDate>
      
      <guid>http://shamaoxiaogui.github.io/post/cpp_primer_note_3/</guid>
      <description>&lt;p&gt;第三章主要讲vector和string&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;string到底是不是以\0结尾的？c++11中规定&lt;strong&gt;&lt;em&gt;是&lt;/em&gt;&lt;/strong&gt;。但是不要依赖这个特性，乖乖的用size()；但是getline的时候换行符确实丢掉了&lt;/li&gt;

&lt;li&gt;&lt;p&gt;auto for循环，注意效率，有些时候auto for效率更高（迭代器最慢～～）&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;chrono&amp;gt;
#include &amp;lt;string&amp;gt;
int main(){
    int n;
    char ch;
    std::cout&amp;lt;&amp;lt;&amp;quot;input n: &amp;quot;;
    std::cin&amp;gt;&amp;gt;n;
    std::cout&amp;lt;&amp;lt;std::endl;
    std::string str(n,&#39;c&#39;);
    std::chrono::high_resolution_clock::time_point t1,t2;
    t1=std::chrono::high_resolution_clock::now();
    for(int i=0;i&amp;lt;n;++i){
        ch=str[i];
    }
    t2=std::chrono::high_resolution_clock::now();
    std::cout&amp;lt;&amp;lt;&amp;quot;for: &amp;quot;&amp;lt;&amp;lt;std::chrono::duration_cast&amp;lt;std::chrono::microseconds&amp;gt;(t2-t1).count()&amp;lt;&amp;lt;&amp;quot; microseconds&amp;quot;&amp;lt;&amp;lt;std::endl;
    t1=std::chrono::high_resolution_clock::now();
    for(auto t:str){
        ch=t;
    }
    t2=std::chrono::high_resolution_clock::now();
    std::cout&amp;lt;&amp;lt;&amp;quot;auto for: &amp;quot;&amp;lt;&amp;lt;std::chrono::duration_cast&amp;lt;std::chrono::microseconds&amp;gt;(t2-t1).count()&amp;lt;&amp;lt;&amp;quot; microseconds&amp;quot;&amp;lt;&amp;lt;std::endl;
    t1=std::chrono::high_resolution_clock::now();
    for(auto &amp;amp;t:str){
        ch=t;
    }
    t2=std::chrono::high_resolution_clock::now();
    std::cout&amp;lt;&amp;lt;&amp;quot;auto&amp;amp; for: &amp;quot;&amp;lt;&amp;lt;std::chrono::duration_cast&amp;lt;std::chrono::microseconds&amp;gt;(t2-t1).count()&amp;lt;&amp;lt;&amp;quot; microseconds&amp;quot;&amp;lt;&amp;lt;std::endl;
    t1=std::chrono::high_resolution_clock::now();
    for(const auto &amp;amp;t:str){
        ch=t;
    }
    t2=std::chrono::high_resolution_clock::now();
    std::cout&amp;lt;&amp;lt;&amp;quot;const auto&amp;amp; for: &amp;quot;&amp;lt;&amp;lt;std::chrono::duration_cast&amp;lt;std::chrono::microseconds&amp;gt;(t2-t1).count()&amp;lt;&amp;lt;&amp;quot; microseconds&amp;quot;&amp;lt;&amp;lt;std::endl;
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ ./fortest.out
input n: 1000000000

for: 9104902 microseconds
auto for: 5651329 microseconds
auto&amp;amp; for: 5445633 microseconds
const auto&amp;amp; for: 5508764 microseconds
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;但是切记范围for不能改变循环序列的大小！！！&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;string的c_str()返回的char*字符串有可能不保证一直有效！！！&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>cpp primer 第二章笔记</title>
      <link>http://shamaoxiaogui.github.io/post/cpp_primer_note_2/</link>
      <pubDate>Tue, 19 Jul 2016 15:16:37 +0800</pubDate>
      
      <guid>http://shamaoxiaogui.github.io/post/cpp_primer_note_2/</guid>
      <description>&lt;p&gt;第二章主要讲的是基本类型，需要注意的有：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;同一个表达式混用&lt;strong&gt;&lt;em&gt;有符号&lt;/em&gt;&lt;/strong&gt;和&lt;strong&gt;&lt;em&gt;无符号&lt;/em&gt;&lt;/strong&gt;数，会自动转换成&lt;strong&gt;&lt;em&gt;无符号&lt;/em&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;字面值前缀指定字符编码，后缀指定变量大小或种类&lt;/li&gt;

&lt;li&gt;&lt;p&gt;字符串字面值不可修改（因为放在一个只读段中）&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;iostream&amp;gt;
int main(){
    char *str=&amp;quot;heheda!&amp;quot;;
    std::cout&amp;lt;&amp;lt;&amp;quot;before m: &amp;quot;&amp;lt;&amp;lt;str&amp;lt;&amp;lt;std::endl;
    str[3]=&#39;a&#39;;
    std::cout&amp;lt;&amp;lt;&amp;quot;after m: &amp;quot;&amp;lt;&amp;lt;str&amp;lt;&amp;lt;std::endl;
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ ./cstr.out
before m: heheda!
[2]    37400 bus error  ./cstr.out
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;c++11&lt;/code&gt;提供了一种新的*列表初始化*，但是效率么。。。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;string&amp;gt;
#include &amp;lt;vector&amp;gt;
class tc{
public:
    tc(){std::cout&amp;lt;&amp;lt;&amp;quot;ct a class! &amp;quot;&amp;lt;&amp;lt;std::endl;}
    tc(const tc &amp;amp;t){std::cout&amp;lt;&amp;lt;&amp;quot;copy a class!&amp;quot;&amp;lt;&amp;lt;std::endl;}
    tc&amp;amp; operator=(tc &amp;amp;t){std::cout&amp;lt;&amp;lt;&amp;quot;= a class!&amp;quot;&amp;lt;&amp;lt;std::endl; return *this;}
};
int main(){
    tc t1;
    std::cout&amp;lt;&amp;lt;&amp;quot;===============&amp;quot;&amp;lt;&amp;lt;std::endl;
    tc t2(t1);
    std::cout&amp;lt;&amp;lt;&amp;quot;===============&amp;quot;&amp;lt;&amp;lt;std::endl;
    tc t3=t1;
    std::cout&amp;lt;&amp;lt;&amp;quot;===============&amp;quot;&amp;lt;&amp;lt;std::endl;
    tc t4{t1};
    std::cout&amp;lt;&amp;lt;&amp;quot;===============&amp;quot;&amp;lt;&amp;lt;std::endl;
    tc t5={t1};
    std::cout&amp;lt;&amp;lt;&amp;quot;===============&amp;quot;&amp;lt;&amp;lt;std::endl;
    std::vector&amp;lt;tc&amp;gt; tcv{t1,t2,t3};
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ ./initlist.out
ct a class!
===============
copy a class!
===============
copy a class!
===============
copy a class!
===============
copy a class!
===============
copy a class!
copy a class!
copy a class!
copy a class!
copy a class!
copy a class!
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;所以在用容器时不要随便用初始化列表，详细见&lt;a href=&#34;https://segmentfault.com/a/1190000002484690&#34;&gt;这里&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;const相关&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;const变量只能初始化不能赋值（哈士奇都知道）&lt;/li&gt;
&lt;li&gt;不加extern的const变量只能在本文件访问（所以说加了呢）&lt;/li&gt;
&lt;li&gt;const左值引用可以绑定：const变量，非const变量，常量（字面量，这也是std::string的设计，只能将字符串传给const std::string &amp;amp;，而不能传给std::string &amp;amp;），无论如何，常量左值引用意味着不能通过这个引用去修改变量&lt;/li&gt;
&lt;li&gt;顶层const指指针本身的值是常量，底层const则是指针指向的值是常量，故而在函数传参或者复制指针时，顶层const忽略（反正就算你是常量我也只是复制你，后面无论怎么操作也不会修改你），底层const则不能忽略（因为有可能通过复制的指针修改数据）&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;constexpr常量表达式，由编译器帮忙检查；using的别名声明功能（类似typedef—）&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;单纯的auto的推断效果：忽略顶层const，然后把表达式的值算出来是啥类型auto就是啥类型。底层const保留。加const的auto推断出来才是顶层const的，auto &amp;amp;推断出来才是引用&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;decltype基本保留变量的所有属性，尤其是当变量为引用时推断出来的结果也是引用。当其表达式是解引用操作时，结果必为引用，而其跟双括号表达式（加了括号的变量），结果必为引用&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;注意类内初始值的初始化顺序：类内初始值－》构造函数初始化列表－》构造函数体&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>cpp primer 第一章笔记</title>
      <link>http://shamaoxiaogui.github.io/post/cpp_primer_note_1/</link>
      <pubDate>Tue, 19 Jul 2016 14:20:39 +0800</pubDate>
      
      <guid>http://shamaoxiaogui.github.io/post/cpp_primer_note_1/</guid>
      <description>&lt;p&gt;第一章只是一个引入，要注意的有：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;std::cin&lt;/code&gt;在读到EOF的情形&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;iostream&amp;gt;
int main(){
    int val;
    while(std::cin&amp;gt;&amp;gt;val){
        std::cout&amp;lt;&amp;lt;val&amp;lt;&amp;lt;&amp;quot; &amp;quot;;
    }
    std::cout&amp;lt;&amp;lt;std::endl;
    std::cout&amp;lt;&amp;lt;&amp;quot;after loop,val= &amp;quot;&amp;lt;&amp;lt;val&amp;lt;&amp;lt;std::endl;
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;测试发现最终结束时，输入C+D(EOF)与输入非数字，最终val的值是不一样的&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;
$ ./istest
1
1 $

after loop,val= 0

$ ./istest
1
1 ^D
    
after loop,val= 1

&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;std::cout,std::cerr,std::clog&lt;/code&gt;的区别&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;iostream&amp;gt;
int main(){
    std::cout&amp;lt;&amp;lt;&amp;quot;from cout&amp;quot;&amp;lt;&amp;lt;std::endl;
    std::clog&amp;lt;&amp;lt;&amp;quot;from clog&amp;quot;&amp;lt;&amp;lt;std::endl;
    std::cerr&amp;lt;&amp;lt;&amp;quot;from cerr&amp;quot;&amp;lt;&amp;lt;std::endl;
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;测试结果：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ ./istest &amp;amp;&amp;amp; echo &amp;quot;======&amp;quot; &amp;amp;&amp;amp; ./istest 2&amp;gt;hehe
from cout
from clog
from cerr
======
from cout
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;总结：
    - cout 标准输出
    - cerr 标准错误
    - clog 标准错误（貌似带缓冲，没验证）&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>about</title>
      <link>http://shamaoxiaogui.github.io/about/</link>
      <pubDate>Sun, 17 Jul 2016 13:46:59 +0800</pubDate>
      
      <guid>http://shamaoxiaogui.github.io/about/</guid>
      <description>&lt;p&gt;Adro，男，西电研狗，私以为生活习性可与草履虫相媲美。&lt;/p&gt;

&lt;p&gt;平时除了调戏女朋友（括弧笑），喜欢嵌入式、撩拨linux、扯扯并发，聊聊服务器。身为一条合格的研狗，坚决执行老板的决定，哪怕老板说：“我们要产品大卖！”嗯，产品大卖。&lt;/p&gt;

&lt;p&gt;厂里，哦不，实验室里主要负责桌面式眼动仪的硬件软件平台设计，一言不合就画板子，写固件，戳USB3.0，码上位机，故而熟悉QT，并发编程，网络通信，熟读程序员腰椎疾病恢复指南。&lt;/p&gt;

&lt;p&gt;遥想当年，意气风发，打过dota，写过合作式调度器，玩过stm32，参加过电赛，如今不过是过眼烟云。&lt;/p&gt;

&lt;p&gt;最后，头像是本人。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>搬家记录</title>
      <link>http://shamaoxiaogui.github.io/post/FirstPost/</link>
      <pubDate>Sun, 17 Jul 2016 13:09:40 +0800</pubDate>
      
      <guid>http://shamaoxiaogui.github.io/post/FirstPost/</guid>
      <description>&lt;p&gt;折腾了一上午，最后还是选择从hexo迁到hugo，记录一下～&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>