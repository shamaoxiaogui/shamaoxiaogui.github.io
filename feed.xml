<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Adro的作死笔记</title>
    <link>http://shamaoxiaogui.github.io/</link>
    <description>Recent content on Adro的作死笔记</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <lastBuildDate>Sat, 23 Jul 2016 09:44:58 +0800</lastBuildDate>
    <atom:link href="http://shamaoxiaogui.github.io/feed/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>深入理解cpp对象模型 第二章笔记</title>
      <link>http://shamaoxiaogui.github.io/post/inside_cpp_object_model_ch2/</link>
      <pubDate>Sat, 23 Jul 2016 09:44:58 +0800</pubDate>
      
      <guid>http://shamaoxiaogui.github.io/post/inside_cpp_object_model_ch2/</guid>
      <description>

&lt;p&gt;构造函数部分：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;先复习下primer对合成默认构造函数的叙述：

&lt;ol&gt;
&lt;li&gt;构造函数不能使用const限定符，一个const对象直到构造函数完成时才获得其“常量”属性。&lt;/li&gt;
&lt;li&gt;编译器只有发现类不包含任何构造函数的情况下才会生成一个默认构造函数。&lt;/li&gt;
&lt;li&gt;如果类中包含没有默认构造函数的类成员，就无法生成合成默认构造函数。&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;inside中，一个没有任何构造函数的类会有一个隐式声明的trivial（没啥用的）构造函数，在以下情况则会有nontrivial（有用的，编译器所需要的，我的理解是，就是我们通常说的合成默认构造函数）&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;如果一个类没有任何构造函数且所有的类成员都有默认构造函数，那么编译器会合成一个默认构造函数（在需要的时候，也就如果在代码中实际定义类的实体才会生成），按类成员的声明顺序来调用它们的默认构造函数。而内置变量成员的初始化则是程序员的责任。如果程序员提供了一个构造函数，来进行内置成员变量的初始化，则编译器会按照上述规则扩充这个函数。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;iostream&amp;gt;
using namespace std;
class c1{
public:
    c1(){cout&amp;lt;&amp;lt;&amp;quot;c1 ctor&amp;quot;&amp;lt;&amp;lt;endl;}
    c1(const c1&amp;amp;){cout&amp;lt;&amp;lt;&amp;quot;c1 copy ctor&amp;quot;&amp;lt;&amp;lt;endl;}
};
class c2{
public:
    c2(){cout&amp;lt;&amp;lt;&amp;quot;c2 ctor&amp;quot;&amp;lt;&amp;lt;endl;}
    c2(const c2&amp;amp;){cout&amp;lt;&amp;lt;&amp;quot;c2 copy ctor&amp;quot;&amp;lt;&amp;lt;endl;}
    virtual ~c2(){}
};
class c3{
public:
    c2 cc2;
    c1 cc1;
    char *str;
};
class c4{
public:
    c4(){cout&amp;lt;&amp;lt;&amp;quot;c4 ctor&amp;quot;&amp;lt;&amp;lt;endl;n=1;}
    c4(const c4&amp;amp;){cout&amp;lt;&amp;lt;&amp;quot;c4 copy ctor&amp;quot;&amp;lt;&amp;lt;endl;}
    c2 cc2;
    c1 cc1;
    int n;
};
int main(){
    c3 cc3;
    cout&amp;lt;&amp;lt;&amp;quot;===========================&amp;quot;&amp;lt;&amp;lt;endl;
    c4 cc4;
    cout&amp;lt;&amp;lt;&amp;quot;===========================&amp;quot;&amp;lt;&amp;lt;endl;
    c4 cc5(cc4);
    cout&amp;lt;&amp;lt;&amp;quot;sizeof c1 &amp;quot;&amp;lt;&amp;lt;sizeof(c1)&amp;lt;&amp;lt;endl;
    cout&amp;lt;&amp;lt;&amp;quot;sizeof c2 &amp;quot;&amp;lt;&amp;lt;sizeof(c2)&amp;lt;&amp;lt;endl;
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ ./classctor.out
c2 ctor
c1 ctor
===========================
c2 ctor
c1 ctor
c4 ctor
===========================
c2 ctor
c1 ctor
c4 copy ctor
sizeof c1 1
sizeof c2 8
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以发现（调皮的我顺路测试了下空类的大小），编译器确实扩展了程序员编写的构造函数(即使是拷贝构造函数，编译器扩展时活着生成时也是调用类成员的默认构造函数)。另外，为了防止在多个文件（编译模块）中生成多个默认构造函数，编译器&lt;strong&gt;&lt;em&gt;把合成的默认构造函数、拷贝构造函数、析构函数，拷贝赋值运算符都以inline的方式完成&lt;/em&gt;&lt;/strong&gt;，因为inline函数只在当前文件作用域有效，如果函数太复杂，就合成为static非inline函数。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;如果一个没有任何构造函数的子类的父类有默认构造函数，那么编译器会合成一个调用父类默认构造函数的合成默认构造函数。如果程序员提供了构造函数，但是没有提供默认构造函数，编译器不会合成一个默认构造函数，但是会扩展所有的构造函数，调用父类的默认构造函数。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;iostream&amp;gt;
using namespace std;
class father{
public:
    father(){cout&amp;lt;&amp;lt;&amp;quot;father ctor&amp;quot;&amp;lt;&amp;lt;endl;}
};
class son:public father{
public:
    int n;
};
class son2:public father{
public:
    son2(int x){n=x;cout&amp;lt;&amp;lt;&amp;quot;son2 ctor&amp;quot;&amp;lt;&amp;lt;endl;}
    int n;
};
int main(){
    son s;
    cout&amp;lt;&amp;lt;&amp;quot;====================&amp;quot;&amp;lt;&amp;lt;endl;
    // son2 s2; //error
    cout&amp;lt;&amp;lt;&amp;quot;====================&amp;quot;&amp;lt;&amp;lt;endl;
    son2 s3(3);
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ ./fatherctor.out
father ctor
====================
====================
father ctor
son2 ctor
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;如果一个类中有virtual方法，不论是声明还是继承来的，因为需要虚表，所以必然得有构造函数来初始化vptr的值令其指向虚表，这种情况下，没有任何构造函数的类编译器会合成一个默认构造函数（为了初始化虚表），有构造函数的编译器会进行相应的扩展。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;相应的，如果类在继承链上有一个虚继承的基类，那么编译器很可能需要在类中插入一个指向该基类的指针（或者其它机制，总之需要进行一翻操作），这就要求一个构造函数来操作。所以这种情况下，如果类没有任何构造函数编译器就合成一个完成该操作的合成默认构造函数；若有程序员提供的构造函数，编译器就扩展它们。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;总结：以上四种情况说明的是 ，&lt;strong&gt;&lt;em&gt;对编译器而言，有必要合成默认构造函数&lt;/em&gt;&lt;/strong&gt;的情况。也就是编译器合成默认构造函数或者扩展构造函数的目的与作用：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;调用类成员的默认构造函数&lt;/li&gt;
&lt;li&gt;调用父类的默认构造函数&lt;/li&gt;
&lt;li&gt;为类初始化虚表相关的操作&lt;/li&gt;
&lt;li&gt;为类初始化虚基类机制&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;一旦上面四条对于一个类来说都不需要，那么合成的默认构造函数被就是trivial（没有用）的，而实际上编译器不会将这种构造函数生成出来。
还记得primer中有个聚合类（aggregate class），当聚合类不含类成员时，上面四个状态就都不满足，那编译器就不会给他生成合成默认构造函数了。所以：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;任何class没有定义构造函数，编译器会生成一个合成默认构造函数&lt;/li&gt;
&lt;li&gt;编译器合成的默认构造函数会初始化所有类的成员&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;这两个观点都不正确&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;同样，拷贝构造函数也有trivial和nontrivial之分，编译器只会生成nontrivial的拷贝构造函数。而判断trivial的标准就在于类是否展现出位逐次拷贝（Bitwise Copy Semantics）特性。首先，看下primer是怎么说的：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;与合成默认构造函数不同，即使我们定义了其它构造函数，编译器也会为我们合成一个拷贝构造函数。&lt;/p&gt;

&lt;p&gt;而一般情况，合成的拷贝构造函数会将其参数的成员逐个拷贝到正在创建的对象中。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;下面是inside的分析：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;当一个类的成员中有一个类，该类成员有拷贝构造函数（不论是它显示声明的，还是编译器因为非位逐次拷贝而生成的。第二个说法有点绕口，其实就是说，如果该类成员也有一个有拷贝构造函数的类成员。。。。递归中。。。。）&lt;/li&gt;

&lt;li&gt;&lt;p&gt;当类的继承链上有一个有拷贝构造函数（和上面括号中描述的一样，两种情况），这两种情况下类是无法进行位逐次拷贝的，此时编译器会生成一个默认拷贝构造函数来调用类成员／基类的拷贝构造函数：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;iostream&amp;gt;
using namespace std;
struct bitwise{
    int n;
    char *hehe;
};
struct goodcopy{
    goodcopy(){}
    goodcopy(const goodcopy&amp;amp;){cout&amp;lt;&amp;lt;&amp;quot;good copy!!&amp;quot;&amp;lt;&amp;lt;endl;}
};
struct nonbitwise{
    goodcopy gc;
};
struct nonbitwise2:public goodcopy{

};
struct nonbitwise3{
    nonbitwise3(){}
    nonbitwise3(const nonbitwise3&amp;amp;){}
    goodcopy gc;
};
int main(){
    bitwise bw1;
    char * str=&amp;quot;blabla!&amp;quot;;
    bw1.hehe=str;
    bw1.n=1;
    bitwise bw2(bw1);
    cout&amp;lt;&amp;lt;&amp;quot;bw1 n &amp;quot;&amp;lt;&amp;lt;bw1.n&amp;lt;&amp;lt;&amp;quot; hehe &amp;quot;&amp;lt;&amp;lt;bw1.hehe&amp;lt;&amp;lt;endl;
    cout&amp;lt;&amp;lt;&amp;quot;bw2 n &amp;quot;&amp;lt;&amp;lt;bw2.n&amp;lt;&amp;lt;&amp;quot; hehe &amp;quot;&amp;lt;&amp;lt;bw2.hehe&amp;lt;&amp;lt;endl;
    cout&amp;lt;&amp;lt;&amp;quot;=============================&amp;quot;&amp;lt;&amp;lt;endl;
    nonbitwise nbw1;
    nonbitwise nbw12(nbw1);
    cout&amp;lt;&amp;lt;&amp;quot;=============================&amp;quot;&amp;lt;&amp;lt;endl;
    nonbitwise2 nbw2;
    nonbitwise2 nbw22(nbw2);
    cout&amp;lt;&amp;lt;&amp;quot;=============================&amp;quot;&amp;lt;&amp;lt;endl;
    nonbitwise3 nbw3;
    nonbitwise3 nbw32(nbw3);
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ ./bitwisecopy.out
bw1 n 1 hehe blabla!
bw2 n 1 hehe blabla!
=============================
good copy!!
=============================
good copy!!
=============================

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面的代码中，不能进行位逐次拷贝的nonbitwise2和nonbitwise都由编译器生成了nontrivial的拷贝构造函数来调用goodcopy的拷贝构造函数；而nonbitwise3虽然也不能位逐次拷贝，但是由于程序员定义了拷贝构造函数，所以编译器没有为其生成，而且也没有对其进行扩展，这一点与默认构造函数不同
1.
如果一个类中含有虚函数，那这个类中必然会有虚表。这样的话，如果这个类之间进行拷贝（子类到子类，类型相同），使用位逐次拷贝是可以的，因为两个类类型相同，虚表指针指向相同的虚表。但是考虑这种情况，当一个子类拷贝给一个父类时，仍然使用位逐次拷贝，可以么？这种情况下的拷贝会发生子类的截断，即只拷贝其基类部分。而位逐次拷贝会使基类的虚表指针指向子类的虚表，而其子类部分又不存在（因为这货是基类啊）所以不能用位逐次拷贝，需要对虚表指针进行处理。综合一下就是，类中含有虚函数，就不能位逐次拷贝。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;同样的，如果一个类的继承链上存在虚继承关系，也不能单纯的用位逐次拷贝处理子类拷贝给父类的情况，而需要编译器合成一个拷贝构造函数。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;对于拷贝构造在函数传参和返回中的使用，主要注意NRV。先来看一个函数是如何返回一个类的：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;struct someone{
    someone(const someone &amp;amp;x){/*...*/}
//...
}
someone func(int n){
    someone t;
    //...
    return t;
}
someone r=func(1);
//实际中编译器很可能会产生如下代码
void func(int n, someone&amp;amp; ret){
    someone t;
    //...
    ret.someone::someone(t);
}
someone r; //此处不执行someone的默认构造函数
func(1,r);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里就可以发现返回类的函数被处理为通过参数来返回的函数了。这时，完全可以省去临时类t：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;void func(int n, someone&amp;amp; ret){
    ret.someone::someone();
    //...
    return;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这就是NRV优化（Named Return Value），也就是对函数中的中间类直接用返回值的引用替换，省去一个临时类，就省去了一次默认构造和拷贝构造以及一次析构的开销。但是NRV也有缺点：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;不同的编译器，其NRV的实现程度不一样，也就是编译器不一定会实现NRV&lt;/li&gt;
&lt;li&gt;不同复杂度的函数，NRV实现程度也不一样&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;这些不确定性让我们不敢依靠NRV来评估软件性能（所以c++11的右值引用是一大亮点）。另外，关于到底要不要明确的写出拷贝构造函数，总结一下就是，如果类可以位逐次拷贝，那就不要写，因为编译器会生成一个trivial的拷贝构造函数，效率很高，自己写的话很有可能使效率下降。至于书中说的explicit copy constructor与NRV的关系，我查了下，见这篇&lt;a href=&#34;http://www.cnblogs.com/cyttina/archive/2012/11/26/2790076.html&#34;&gt;文章&lt;/a&gt;，就是说，嗯，没关系。。。。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;最后，关于构造函数初始化列表：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;注意初始化顺序，按成员声明的顺序来。尽量不要交织。&lt;/li&gt;
&lt;li&gt;尤其不要用在子类的初始化列表中用子类的成员函数为父类的构造函数提供参数，比如：&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;struct father{
    //...
    father(int n){/*...*/}
    //...
};
struct son:public father{
    //...
    son(int x):_t(x),father(memberfunc(x)){/*...*/}
    //...
    int memberfunc(int n){/*...*/}
    int _t;
};
//...  编译器有可能把初始化列表转化为
// son::son(/*...this pointer...*/){
    // father::father(this,this-&amp;gt;memberfunc(x)); //尼玛，this的son部分还没构建你就以及调用它的方法了！！！！！
    // _t=x;
// }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最后注意，在构造活着析构函数中调用虚函数，虚函数一定是当前构造／析构函数所属类型的虚函数，因为再往下，子类部分要不还没构建，要不就已经析构了。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;

&lt;p&gt;对于构造函数，一句总结就是，如果写了任何构造函数，编译器就不会给你生成默认构造函数了。对于拷贝构造，不需要明确写的就不要写，对于初始化列表，不要“交织”！&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>cpp primer 第十五章笔记</title>
      <link>http://shamaoxiaogui.github.io/post/cpp_primer_note_15/</link>
      <pubDate>Thu, 21 Jul 2016 10:57:42 +0800</pubDate>
      
      <guid>http://shamaoxiaogui.github.io/post/cpp_primer_note_15/</guid>
      <description>&lt;p&gt;终于到了第十五章了，复习大计实施的还不错～～&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;动态绑定可以用指针或者引用实现&lt;/li&gt;
&lt;li&gt;基类的析构函数一般都应该是virtual修饰的，因为通常我们会在一个基类指针中存放一个派生类的指针，delete这个指针时编译器要调用合适的析构函数，讲基类的析构函数定义为virtual的使编译器自动调用派生类的析构函数。不用担心，析构时仍然会调用基类的析构函数&lt;/li&gt;
&lt;li&gt;在用于覆盖虚函数的函数后面可以添加关键字override来显示注明，位置是const和引用限定符后面&lt;/li&gt;
&lt;li&gt;静态成员可以被继承切在整个继承体系中只有一个&lt;/li&gt;
&lt;li&gt;防止继承，在类定义后面加final关键字&lt;/li&gt;
&lt;li&gt;基类的拷贝构造函数不是虚函数，因为用一个派生类给基类赋值只会赋值派生类中的基类部分&lt;/li&gt;
&lt;li&gt;类中普通的成员函数我们可以只提供声明而不定义，只要不使用即可，但是必须为所有的虚函数提供定义，因为直到运行时才会知道哪个虚函数被使用了&lt;/li&gt;
&lt;li&gt;引用和指针的静态类型与动态类型不同这一事实正是C++语言支持多态的根本所在&lt;/li&gt;
&lt;li&gt;如果派生类中覆盖了某个虚函数，它可以再一次使用virtual指定其虚函数属性，然而这是&lt;strong&gt;&lt;em&gt;没必要的&lt;/em&gt;&lt;/strong&gt;，因为一旦某个函数被声明为虚函数，在整个继承体系中它都是虚函数。&lt;/li&gt;
&lt;li&gt;派生类要覆盖虚函数，新函数必须有与虚函数一样的参数和返回值，唯一的&lt;strong&gt;&lt;em&gt;例外&lt;/em&gt;&lt;/strong&gt;是，如果虚函数返回的是类本身（基类）的指针或引用，那么覆盖函数允许返回派生类的指针或引用&lt;/li&gt;
&lt;li&gt;也可以将某个函数指定为final，防止后续派生类覆盖它（一般用于间接派生中，自己定义了一个覆盖父类的虚函数，但是不希望后续子类覆盖它）&lt;/li&gt;
&lt;li&gt;虚函数中使用默认实参是依赖与当前的&lt;strong&gt;&lt;em&gt;静态类型&lt;/em&gt;&lt;/strong&gt;的！！！所以最好将一个虚函数所有的覆盖函数中的默认实参定义成一样的，防止出错&lt;/li&gt;
&lt;li&gt;使用作用域运算符可以回避虚函数机制，静态指定调用目标，这一般用在派生类的虚函数需要调用基类的虚函数做一些操作的时候，此时如果不指定作用域，运行时会被解析为调用自身，从而无限递归&lt;/li&gt;
&lt;li&gt;纯虚函数，带 =0 的虚函数，可以不提供定义（一般不提供），也可以提供，但是必须在类外定义。&lt;/li&gt;
&lt;li&gt;含有（或者直接继承，没有覆盖）纯虚函数的类是抽象基类，抽象基类不能创建对象&lt;/li&gt;
&lt;li&gt;protected成员：

&lt;ol&gt;
&lt;li&gt;用户不可访问，但是对其派生类和其友元是可以访问的（注意是基类的友元）&lt;/li&gt;
&lt;li&gt;对于派生类的友元，想要访问基类的protected成员，只能通过派生类来“代理”访问&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;关于派生类向基类转换的可访问性，引用primer的总结，&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;对于代码中的某个给定节点来说，如果基类的公有成员是可访问的，则派生类向基类的类型转换也是可访问的；反之则不行。&lt;/p&gt;
&lt;/blockquote&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;友元没有传递性，友元也不能继承&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;可以用using声明改变继承来的可访问成员的可访问性（比如把private继承来的某父类成员用using声明变成public的）&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;struct默认访问说明符为public，默认继承保护级别也是public；而class默认访问说明符是private的，默认继承保护级别也是private（but还是显示声明吧。。。）&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;指针和引用的静态类型决定哪些成员可见&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;名字查找先于类型检查，所以派生类中的函数会隐藏掉基类中的同名函数，即使二者函数签名不同，也不会构成函数重载&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;所以说，如果在覆盖虚函数的时候写错了参数，不但不能覆盖虚函数（用基类指针调用虚函数调用的是基类的虚函数），而且还会在派生类中隐藏掉该虚函数（用该派生类指针调用虚函数会报错，因为虚函数被隐藏了），比如：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;iostream&amp;gt;
class base{
public:
    virtual int func(){std::cout&amp;lt;&amp;lt;&amp;quot;base v&amp;quot;&amp;lt;&amp;lt;std::endl;}
};
class d1:public base{
public:
    int func(int n){std::cout&amp;lt;&amp;lt;&amp;quot;d1 func&amp;quot;&amp;lt;&amp;lt;std::endl;}
};
int main(){
    base *bp=new d1;
    d1 *dp=bp;
    bp-&amp;gt;func();     //调用的是base的虚函数func
    //dp-&amp;gt;dunc();     //编译错误，因为对d1而言，base的虚函数func被d1的func(int)隐藏了
    delete bp;
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;起始对于派生类来说，基类的虚函数和非虚函数都可以覆盖，只不过覆盖虚函数可以在其基类指针中动态调用，而非虚函数不行。但是，一旦定义一个名字与基类中某个函数一样的函数，基类中的函数就被覆盖了，基类中的所有的该函数的重载函数也一样。所以如果想在派生类中使用基类的所有重载函数，要不就不要覆盖，要不就把每个重载函数都覆盖。或者，用一条using声明将基类中的函数“拿”到派生类的public域中，然后再覆盖其中要覆盖的函数。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;iostream&amp;gt;
class base{
public:
    void func(){std::cout&amp;lt;&amp;lt;&amp;quot;bfunc&amp;quot;&amp;lt;&amp;lt;std::endl;}
    void func(int n){std::cout&amp;lt;&amp;lt;&amp;quot;bfunc2&amp;quot;&amp;lt;&amp;lt;std::endl;}
    int x=0;
};
class d1:public base{
public:
    using base::func;
    void func(){std::cout&amp;lt;&amp;lt;&amp;quot;dfunc&amp;quot;&amp;lt;&amp;lt;std::endl;}
    using base::x;
    int x=1;
};
int main(){
    d1 d;
    d.func();
    d.func(3);
//    std::cout&amp;lt;&amp;lt;&amp;quot;d.x=&amp;quot;&amp;lt;&amp;lt;d.x&amp;lt;&amp;lt;std::endl;    //二义性错误
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;派生类的构造函数、拷贝构造函数、拷贝赋值运算符以及移动构造函数、移动赋值运算符都应该显式调用基类的相关函数，传入复制／移动对象即可，因为基类的这些函数参数一定是个引用，基类可以引用派生类。而析构函数则不需要，只释放自己的资源就好。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;如果在构造或析构函数中调用了虚函数，调用的是当前函数对应类的虚函数版本，不会调用派生类的版本，因为此时派生类部分还没有初始化活着已经析构了，不存在（换句话说，此时虚表中不存在派生类的信息）。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;iostream&amp;gt;
using namespace std;
class base{
public:
    base(){vfunc();}
    virtual void vfunc(){cout&amp;lt;&amp;lt;&amp;quot;base n: &amp;quot;&amp;lt;&amp;lt;n&amp;lt;&amp;lt;endl;}
    virtual ~base(){cout&amp;lt;&amp;lt;&amp;quot;d base &amp;quot;;vfunc();}
private:
    int n=0;
};
class d1:public base{
public:
    d1(){vfunc();}
    void vfunc(){cout&amp;lt;&amp;lt;&amp;quot;d1 x: &amp;quot;&amp;lt;&amp;lt;x&amp;lt;&amp;lt;endl;}
    ~d1(){cout&amp;lt;&amp;lt;&amp;quot;d d1&amp;quot;;vfunc();}
private:
    int x=1;
};
int main(){
    // d1 d;
    base *bp=new d1;
    delete bp;
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ ./dcvirtual.out
base n: 0
d1 x: 1
d d1d1 x: 1
d base base n: 0
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;因为向一个基类赋值派生类会产生“截断”现象（因为调用的是基类的拷贝函数），所以不要在容器中直接存储基类对象，这样一旦你向其中放入派生类，就会截断，切编译器不会报错。应在容器中存储基类指针。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>cpp primer 第十四章笔记</title>
      <link>http://shamaoxiaogui.github.io/post/cpp_primer_note_14/</link>
      <pubDate>Thu, 21 Jul 2016 09:18:59 +0800</pubDate>
      
      <guid>http://shamaoxiaogui.github.io/post/cpp_primer_note_14/</guid>
      <description>&lt;p&gt;第十四章主要讲运算符重载和类型转换（感觉每次第一句话都是废话）：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;不应该被重载的运算符：&lt;code&gt;&amp;amp;&amp;amp; || ,&lt;/code&gt;因为无法保留其运算顺序（还有逻辑运算符的短路运算属性），而对于逗号和取址运算，语言已经定义了其对于类的特殊含义&lt;/li&gt;
&lt;li&gt;必须定义为成员函数的运算符：&lt;code&gt;= [] () -&amp;gt;&lt;/code&gt;（语言也禁止这样做）&lt;/li&gt;
&lt;li&gt;对于需要对称性的运算符（＋），可能会转换任一端参数，定义为普通函数&lt;/li&gt;
&lt;li&gt;对于输入输出运算符的重载，注意：

&lt;ol&gt;
&lt;li&gt;减少格式化输出，不应该添加换行符&lt;/li&gt;
&lt;li&gt;输入输出运算符必须是非成员函数&lt;/li&gt;
&lt;li&gt;输入运算符中应处理出错情况，负责从错误中恢复；输出运算符则不需要考虑错误&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;同时定义了算术运算符和相关的复合赋值运算，应优先使用复合赋值（开销小）&lt;/li&gt;

&lt;li&gt;&lt;p&gt;递增递减运算的原型：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class X{
public:
    X&amp;amp; operator++();    //前置
    X operator++(int);  //后置，其中参数不会用到
};
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;下表运算一般定义两个版本，普通的返回引用，加const限定符的返回常量引用&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;lambda表达式产生的类不含默认构造函数、赋值运算符、默认析构函数&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;cpp的可调用对象有：函数、函数指针、lambda表达式、bind对象、函数对象&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;std::function模版可以用来存放或者说是接受可调用对象，但是不能放重载函数，解决方案是使用函数指针活着lambda给重载函数做一个“别名”。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;类型转换函数，可以定义为转换成任何能作为函数返回类型的类型（数组、函数类型就不行，但是数组指针和函数指针可以）；必须是类的成员函数；无返回类型参数列表；通常const限定：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;operator type() const;
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;显示的类型转换运算符，就是在前面加explicit，使用时必须用cast。例外：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;if，while，do语句条件部分&lt;/li&gt;
&lt;li&gt;for语句条件部分&lt;/li&gt;
&lt;li&gt;&lt;code&gt;! || &amp;amp;&amp;amp;&lt;/code&gt;运算对象&lt;/li&gt;
&lt;li&gt;条件运算符表达式（?:）的条件部分&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;这些语句中会隐式的调用显示类型转换运算符中转换为bool的那类。比如io库中，我们经常用：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;while(cin&amp;gt;&amp;gt;n){
...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;所以，一般向bool型的类型转换我们可以大胆的写成explicit的（一般也只定义向bool的转换）&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>cpp primer 第十三章笔记</title>
      <link>http://shamaoxiaogui.github.io/post/cpp_primer_note_13/</link>
      <pubDate>Wed, 20 Jul 2016 21:40:45 +0800</pubDate>
      
      <guid>http://shamaoxiaogui.github.io/post/cpp_primer_note_13/</guid>
      <description>&lt;p&gt;嘿嘿，飙到第十三章了～～老司机的笑容像天上的弦月～～毕竟是补漏。。。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;拷贝构造函数通常不应该是explicit的，参数必须为引用类型（常量引用）&lt;/li&gt;
&lt;li&gt;合成的拷贝构造函数对于数组成员会逐一拷贝其元素&lt;/li&gt;
&lt;li&gt;编译器有时会绕过拷贝构造函数（优化为直接构造）&lt;/li&gt;
&lt;li&gt;三／五法则：析构函数，拷贝构造函数，拷贝赋值运算符，移动构造函数，移动赋值运算符，可以看成一个整体，通常需要定义其中一个也就意味着需要定义其余四个。&lt;/li&gt;
&lt;li&gt;新司机还记得&lt;code&gt;=default&lt;/code&gt;不？&lt;/li&gt;
&lt;li&gt;阻止拷贝：旧标准可以把相关构造函数&lt;strong&gt;&lt;em&gt;声明&lt;/em&gt;&lt;/strong&gt;为private，不需要定义；新标准可以用&lt;code&gt;=delete&lt;/code&gt;。当不能拷贝、赋值或销毁类的成员时，类的合成拷贝控制成员就被定义为删除的&lt;/li&gt;
&lt;li&gt;对于一个赋值运算符，编写时需要考虑：

&lt;ol&gt;
&lt;li&gt;一个对象赋值给它自身，要工作正常（所以要在析构当前对象前保存“新”对象）&lt;/li&gt;
&lt;li&gt;拷贝＋析构&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;如果swap操作不会拷贝对象而只是交换指针（通常都是如此），那么可以利用“拷贝并交换”技术来编写赋值运算：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;tc&amp;amp; operator=(tc rhs){  //传值复制了rhs
    swap(*this,rhs);    
    return *this;
}   //rhs也就是原来的本对象会自动析构
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;左值引用不能绑定到&lt;strong&gt;&lt;em&gt;要求转换的表达式、字面常量、返回右值的表达式&lt;/em&gt;&lt;/strong&gt;，但是常量左值引用可以哦，而右值引用则和左值引用完成相反&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;int i=10;
double &amp;amp;rd=i;   //error
int &amp;amp;ri=30;     //error
int &amp;amp;rri=i+3;   //error
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;右值短暂，都是临时对象，左值持久。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;右值和右值引用是不一样的，简单的说，右值就是临时量，不是变量，而右值引用是引用右值的变量，是个变量，它通过引用右值（临时量）将临时量变为变量，本来临时量马上就会消亡，你一用右值引用引用它，就把它变成一个持久的变量了，所以primer说，右值引用从绑定到其的临时量中“窃取”状态。同样的，右值引用是一个变量不是临时量，所以右值引用不能绑定右值引用（绕口。。。），还有，右值意味着它只有你这个所有者，你可以为所欲为（修改它）&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;使用&lt;code&gt;std::move&lt;/code&gt;可以将一个左值转换为右值引用，也就是告诉编译器，这个左值劳资要当成右值用，你放心，过会儿劳资就削了它！（也就是说除了销魂不能对它再做任何操作，起始还可以再赋值给他，但是不能直接使用它的值。。。）
1.
移动构造函数和移动赋值运算符，参数都是非const的右值引用，调用后移后对象应处于可析构状态（意思是说，假设把a移动给b，就算你在调用移动构造函数之后把a析构了，也不会影响到b的内容，主要是考虑指针的处理），再者二者不应该抛出异常，使用noexcept关键字（编译器看到这个关键字的话，在这个函数抛出异常时，会直接调用terminate()，同时，它也告诉标准库容器该类的移动构造函数不会抛出异常，否则，标准库会因为预防发生异常的时候需要恢复原状而使用拷贝语义）。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;拷贝左值，移动右值，没有移动就只能拷贝右值&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;标准库的重载函数往往有两个版本：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;void push_back(const X&amp;amp;);   //copy
void push_back(X&amp;amp;&amp;amp;);    //move
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;拷贝操作对参数应该没有影响，故而必然是const的，而移动操作会对移后对象进行操作，所以必然是非const的&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;可以在成员函数后面活着重载运算符后面加引用限定符表示this指向的对象只能是左值或者右值&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class foo{
public:
    foo&amp;amp; operator=(const foo&amp;amp;) &amp;amp;;   //只有左值才能使用＝
    void somefunc() &amp;amp;&amp;amp;;     //只有右值才能使用该函数
    void hehe() const &amp;amp;;    //只有const左值才能使用该函数，const必须在前
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;至于重载函数，const限定符的成员函数和同名同参的普通成员函数构成重载，而不同引用限定符的同名同参成员函数之间也构成重载，重载的对象就是类本身是左值还是右值。另外，一旦在const限定符与普通重载函数之间的任何一个上用了引用限定符，那这一组重载函数中就都得用引用限定符了；&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>cpp primer 第七章笔记</title>
      <link>http://shamaoxiaogui.github.io/post/cpp_primer_note_7/</link>
      <pubDate>Wed, 20 Jul 2016 16:36:02 +0800</pubDate>
      
      <guid>http://shamaoxiaogui.github.io/post/cpp_primer_note_7/</guid>
      <description>&lt;p&gt;第七章，终于到正题了，类：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;只有在类中没有任何构造函数时，编译器才会生产合成默认构造函数；只有当类内部的内置类型被赋予类内初始值时，合成默认构造函数才有可能合适；如果类内包含其它的没有默认构造函数的类时，编译器不能为其生成合成默认构造函数；可以明确指定使用合成默认构造函数：&lt;code&gt;xxx()=default;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;继承的三种方式，参见&lt;a href=&#34;http://blog.csdn.net/complety/article/details/7493194&#34;&gt;文章&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;友元也会被继承，但是友元类不具有传递性；友元声明仅仅是友元声明，一般需要在类定义外加一个普通函数声明（一般类定义是放在头文件的，所以一般也需要这个普通函数声明），虽然有的编译器不这么要求&lt;/li&gt;
&lt;li&gt;mutable关键字是说，即使类的实体是个const实体，其mutable成员也是可以改变的&lt;/li&gt;
&lt;li&gt;类内初始值可以用＝和花括号&lt;/li&gt;
&lt;li&gt;对于类中的const、引用或者未提供默认构造函数的类成员，必须用类内初始值或者构造函数的初始值列表来初始化，而不能直接在构造函数中“初始化”（原因很简单，构造函数中的“初始化”实际上是先对成员进行默认初始化，然后赋值，上面这三种都不能默认初始化）&lt;/li&gt;

&lt;li&gt;&lt;p&gt;关于构造顺序，我们可以做个实验：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;string&amp;gt;
using std::string;
using std::cout;
using std::endl;
class member{
public:
    member(int n):m(n){cout&amp;lt;&amp;lt;&amp;quot;member &amp;quot;&amp;lt;&amp;lt;m&amp;lt;&amp;lt;&amp;quot; ctor&amp;quot;&amp;lt;&amp;lt;endl;}
    ~member(){cout&amp;lt;&amp;lt;&amp;quot;member &amp;quot;&amp;lt;&amp;lt;m&amp;lt;&amp;lt;&amp;quot; dctor&amp;quot;&amp;lt;&amp;lt;endl;}
private:
    int m; 
};
class grandpa{
public:
    grandpa(const string&amp;amp; n=&amp;quot;G&amp;quot;):name(n){cout&amp;lt;&amp;lt;&amp;quot;grand &amp;quot;&amp;lt;&amp;lt;name&amp;lt;&amp;lt;&amp;quot; ctor&amp;quot;&amp;lt;&amp;lt;endl;}
    ~grandpa(){cout&amp;lt;&amp;lt;&amp;quot;grand &amp;quot;&amp;lt;&amp;lt;name&amp;lt;&amp;lt;&amp;quot; dctor&amp;quot;&amp;lt;&amp;lt;endl;}
private:
    string name;
};
class father:public grandpa{
public:
    father(const string&amp;amp; n=&amp;quot;F&amp;quot;):name(n){cout&amp;lt;&amp;lt;&amp;quot;father &amp;quot;&amp;lt;&amp;lt;name&amp;lt;&amp;lt;&amp;quot; ctor&amp;quot;&amp;lt;&amp;lt;endl;}
    ~father(){cout&amp;lt;&amp;lt;&amp;quot;father &amp;quot;&amp;lt;&amp;lt;name&amp;lt;&amp;lt;&amp;quot; dctor&amp;quot;&amp;lt;&amp;lt;endl;}
private:
    string name;
};
class child:public father{
public:
    child(const string&amp;amp; n=&amp;quot;C&amp;quot;):m1(1),m2(2),m3(3),name(n){cout&amp;lt;&amp;lt;&amp;quot;child &amp;quot;&amp;lt;&amp;lt;name&amp;lt;&amp;lt;&amp;quot; ctor&amp;quot;&amp;lt;&amp;lt;endl;}
    ~child(){cout&amp;lt;&amp;lt;&amp;quot;child &amp;quot;&amp;lt;&amp;lt;name&amp;lt;&amp;lt;&amp;quot; dctor&amp;quot;&amp;lt;&amp;lt;endl;}
private:
    string name;
    static member m4;
    member m1,m2,m3;
};
member child::m4(4);
int main(){
    child ch;
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ ./initorder.out
member 4 ctor
grand G ctor
father F ctor
member 1 ctor
member 2 ctor
member 3 ctor
child C ctor
child C dctor
member 3 dctor
member 2 dctor
member 1 dctor
father F dctor
grand G dctor
member 4 dctor
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;总结一下：首先，类的静态变量和程序的全局变量一起初始化，然后类的父类初始化，然后类自身初始化，其中成员按照定义的顺序初始化，最后执行类自身的构造函数。析构的时候，完全反过来：先调用自己的析构，然后逆着成员的定义顺序析构成员，最后调用父类的析构函数。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;委托构造函数，嗯，好东西，有了这个就不需要之前的init辅助函数&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;explicit禁止隐式转换，切不能当成拷贝初始化，但可以用构造函数显示转换为临时对象，或者static_cast也可以&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;聚合类的条件：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;所有成员public&lt;/li&gt;
&lt;li&gt;没定义任何构造函数&lt;/li&gt;
&lt;li&gt;没有类内初始值&lt;/li&gt;
&lt;li&gt;没有基类，没有虚函数&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>cpp primer 第六章笔记</title>
      <link>http://shamaoxiaogui.github.io/post/cpp_primer_note_6/</link>
      <pubDate>Wed, 20 Jul 2016 14:49:08 +0800</pubDate>
      
      <guid>http://shamaoxiaogui.github.io/post/cpp_primer_note_6/</guid>
      <description>&lt;p&gt;第六章主要是函数相关的内容：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;函数是可以没有定义只有声明的，只要你不用它（变量声明，类的前置声明也是）。。。&lt;/li&gt;
&lt;li&gt;关于引用与指针，我觉得最重要的区别的话，主要是

&lt;ol&gt;
&lt;li&gt;引用初始化后就不能再改变引用的对象了，而指针可以指向不同的对象&lt;/li&gt;
&lt;li&gt;有空指针没有空引用&lt;/li&gt;
&lt;li&gt;引用是对象的别名，不是一个对象，而指针是一个专门用来存放地址的对象，所以sizeof二者会有区别&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;对于函数的参数，可以理解为c++只有传值，没有传引用，其传引用是通过对地址的传值实现的。数组传引用时会退化成指针，当使用引用来作为数组形参时，需要指定维度，不符合维度的数组不能匹配到该函数&lt;/li&gt;
&lt;li&gt;又到了可爱的initializer_list，记住注意复制开销&lt;/li&gt;
&lt;li&gt;关于函数return临时对象的问题，参见&lt;a href=&#34;http://www.cnblogs.com/xkfz007/articles/2506022.html&#34;&gt;文章&lt;/a&gt;，可见编译器帮我们做了很多事情，但是仍然注意后面的右值引用和完美转发&lt;/li&gt;
&lt;li&gt;inline和constexpr函数可以定义多次，但是定义必须完全一样，所以一般把它们放到头文件中&lt;/li&gt;

&lt;li&gt;&lt;p&gt;对于函数对象和函数的比较，发现效率似乎差距不大（clang）&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;chrono&amp;gt;
auto func1(int t)-&amp;gt;int{
    return ++t;
}
class func2{
public:
    auto operator()(int t)-&amp;gt;int{
        return ++t;
    }
};
inline int func3(int t){
    return ++t;
}
static inline int func4(int t){
    return ++t;
}
int main(){
    int n,i=0;
    std::chrono::high_resolution_clock::time_point t1,t2;
    std::cout&amp;lt;&amp;lt;&amp;quot;input: &amp;quot;;
    std::cin&amp;gt;&amp;gt;n;
    std::cout&amp;lt;&amp;lt;std::endl;
    std::cout&amp;lt;&amp;lt;&amp;quot;=========================&amp;quot;&amp;lt;&amp;lt;std::endl;
    t1=std::chrono::high_resolution_clock::now();
    for(int j=0;j&amp;lt;n;++j){
        i=func1(j);
    }
    t2=std::chrono::high_resolution_clock::now();
    std::cout&amp;lt;&amp;lt;&amp;quot;time: &amp;quot;&amp;lt;&amp;lt;std::chrono::duration_cast&amp;lt;std::chrono::microseconds&amp;gt;(t2-t1).count()&amp;lt;&amp;lt;&amp;quot; microseconds&amp;quot;&amp;lt;&amp;lt;std::endl;
    std::cout&amp;lt;&amp;lt;&amp;quot;=========================&amp;quot;&amp;lt;&amp;lt;std::endl;
    func2 func2i;
    t1=std::chrono::high_resolution_clock::now();
    for(int j=0;j&amp;lt;n;++j){
        i=func2i(j);
    }
    t2=std::chrono::high_resolution_clock::now();
    std::cout&amp;lt;&amp;lt;&amp;quot;time: &amp;quot;&amp;lt;&amp;lt;std::chrono::duration_cast&amp;lt;std::chrono::microseconds&amp;gt;(t2-t1).count()&amp;lt;&amp;lt;&amp;quot; microseconds&amp;quot;&amp;lt;&amp;lt;std::endl;
    std::cout&amp;lt;&amp;lt;&amp;quot;=========================&amp;quot;&amp;lt;&amp;lt;std::endl;
    t1=std::chrono::high_resolution_clock::now();
    for(int j=0;j&amp;lt;n;++j){
        i=func3(j);
    }
    t2=std::chrono::high_resolution_clock::now();
    std::cout&amp;lt;&amp;lt;&amp;quot;time: &amp;quot;&amp;lt;&amp;lt;std::chrono::duration_cast&amp;lt;std::chrono::microseconds&amp;gt;(t2-t1).count()&amp;lt;&amp;lt;&amp;quot; microseconds&amp;quot;&amp;lt;&amp;lt;std::endl;
    std::cout&amp;lt;&amp;lt;&amp;quot;=========================&amp;quot;&amp;lt;&amp;lt;std::endl;
    t1=std::chrono::high_resolution_clock::now();
    for(int j=0;j&amp;lt;n;++j){
        i=func4(j);
    }
    t2=std::chrono::high_resolution_clock::now();
    std::cout&amp;lt;&amp;lt;&amp;quot;time: &amp;quot;&amp;lt;&amp;lt;std::chrono::duration_cast&amp;lt;std::chrono::microseconds&amp;gt;(t2-t1).count()&amp;lt;&amp;lt;&amp;quot; microseconds&amp;quot;&amp;lt;&amp;lt;std::endl;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ ./functest.out
input: 1000000000

=========================
time: 3859925 microseconds
=========================
time: 3849522 microseconds
=========================
time: 3647694 microseconds
=========================
time: 3865106 microseconds
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>cpp primer 第五章笔记</title>
      <link>http://shamaoxiaogui.github.io/post/cpp_primer_note_5/</link>
      <pubDate>Wed, 20 Jul 2016 13:59:57 +0800</pubDate>
      
      <guid>http://shamaoxiaogui.github.io/post/cpp_primer_note_5/</guid>
      <description>&lt;p&gt;第五章讲解语句：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;注意switch内部块中定义的变量，尽管在同一个作用域中（case后面不跟大括号的情况），但是只要是没有初始化的变量就不能使用，比如&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;switch(ch){
case &#39;a&#39;:
    string name;    //错误，可能绕开隐式初始化
    int a=0;    //错误，可能绕开显示初始化
    int b;  //正确，未初始化，可以在其他控制块中初始化
    break;
case &#39;b&#39;:
    b=1;    //正确，赋值
    if(name.empty())    //错误，虽然在作用域内，但没有初始化
    //...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;简单有效的做法是，限定作用域，即在case后使用大括号&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;关于异常，这里引用陈硕在知乎上的回答：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;作者：陈硕
链接：&lt;a href=&#34;http://www.zhihu.com/question/22889420/answer/22975569&#34;&gt;http://www.zhihu.com/question/22889420/answer/22975569&lt;/a&gt;
来源：知乎
著作权归作者所有，转载请联系作者获得授权。&lt;/p&gt;

&lt;p&gt;整个 C++ exception 的行为在常见语言中是最奇葩的， 因为这个语言特性与 C++ 其他 feature（特别是确定性析构） 格格不入。在 C++ 中全面铺开使用异常会遇到其他语言中不存在的问题。&lt;/p&gt;

&lt;p&gt;从网上容易找到一些公司/组织的C++编码规范，其中至少 Google、Mozilla、Qt、LLVM 这几家的规范是明确禁用异常的。前面三家或许可以用代码历史包袱、程序员C++水平参差不齐、保证可移植性等理由来解释，但是 LLVM 却不同。首先，LLVM 在 2003 年才发布第一版，是个21世纪的新项目，没什么历史包袱；更重要的是，LLVM 的作者同时也开发了 clang 这个 C++ 编译器，用 C++ 写 C++ 编译器的程序员恐怕是 C++ 程序员里对语言掌握得最好的那一批，如果他们都在项目中明确地禁用异常，这意味着什么呢？注意到 clang 源码已经用上了 C++11，那么“考虑移植性照顾老host编译器”这条理由似乎也不成立了。&lt;/p&gt;

&lt;p&gt;C++ 引入异常的原因之一是为了能让构造函数报错（析构函数不能抛异常这是大家都知道的常识），毕竟构造函数没有返回值，没有异常的话调用方如何得知对象构造是否成功呢？但是编译器/标准库为了让构造函数能抛异常却是麻烦重重：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;数组元素构造时抛异常，前面已经构造好的元素要析构，还没有构造的元素不能析构。&lt;/li&gt;
&lt;li&gt;构造函数的初始化列表里抛异常，前面已经构造好的成员和基类子对象要析构，还没有构造的成员则不能析构。而且这个异常捕获之后必须重新抛出（编译器强制），因为C++不允许“半吊子”构造的对象存在。&lt;/li&gt;
&lt;li&gt;多继承中某个基类的构造函数抛异常，那么已经构造好的基类子对象要析构，还没有构造的基类子对象则不能析构。虚拟继承，虚基类只能析构一次，你慢慢想吧。&lt;/li&gt;
&lt;li&gt;函数实参对象构造时抛异常，那么多个实参中已经构造好的实参对象要析构，尚未构造的实参对象不能析构。&lt;/li&gt;
&lt;li&gt;std::vector 在 resizing 的时候某个元素的拷贝发生异常，那么前面已经拷贝的元素要析构，尚未拷贝的元素则不必也不能析构，去看 gcc vector::_M_insert_aux 的代码有多麻烦。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;（注脚：C++ 引入异常的另一个原因是让 dynamic_cast&lt;Derived&amp;&gt;(baseReference) 能报错，因为没有 null reference。还有一个原因是让 overloaded operator 能报错，毕竟 operator 的返回类型往往无法包含 error code，例如 operator=() 返回的是 Type&amp;amp;。C++ 也是唯一一个变量赋值有可能会抛异常的语言，例如 Person s; s = getPersonById(someId);，那么即便 getPersonById() 不抛异常也不能保证上一句赋值不抛异常。）&lt;/p&gt;

&lt;p&gt;（注脚2：C++ 引入异常的政治原因是 Ada 支持异常，而 Ada 是 DoD 的指定官方语言，如果 C++ 不支持异常，那么 AT&amp;amp;T 贝尔实验室就不能拿 C++ 做 DoD 的项目。）&lt;/p&gt;

&lt;p&gt;C++ 编译器要随时提防调用某个函数 foo 会抛异常，这会阻止一些优化，也会产生很多累赘的代码（随时准备析构那些调用 foo 函数前已经构造好的栈上对象）。因此 C++11 的 noexcept 应该大力推广。&lt;/p&gt;

&lt;p&gt;C++ 的 exception specification 也很鸡肋，它不像 Java 那样在编译期检查（Java 似乎也流行使用 unchecked exception 了），而是在运行期检查，而且违反的后果是直接终止程序，那谁敢用啊？还不如用代码注释呢。有的编译器干脆就只支持语法而不实现功能（Exception Specifications）。C# 也不支持 exception specification，可见这是一项无用的语言特性，算是编程语言发展历史上走的弯路吧，可惜 Java/C++ 掉坑里了。&lt;/p&gt;

&lt;p&gt;其他支持异常的语言几乎都有 GC，抛异常就抛了，不用担心析构，反正GC管着。只有 C++ 才有 exception safety 需要考虑，其他支持异常的语言都没有这一概念。&lt;/p&gt;

&lt;p&gt;而且 Java 的 try-with-resource，C# 的 using，Python 的 with 在管理 function local scope 对象的生命期（资源、lock 释放）方面不比 RAII 麻烦。Go defer 要差一些，它是 function 级，不是 block 级，只能对付 return。 不过反正 Go 也没异常，有点小坑罢了，把函数写短点就能绕过。&lt;/p&gt;

&lt;p&gt;RAII 的优势在于将对象的生命期管理与其他资源（锁、文件、网络连接等等）的管理整合，然后通过 smart pointers 一并解决了，这是 C++ 独一无二的优势。&lt;/p&gt;

&lt;p&gt;如果写递归下降的 parser，那么内部用异常来报错似乎是合理的，对外返回一个 error code 即可。&lt;/p&gt;
&lt;/blockquote&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;总之，呵呵～～&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>cpp primer 第四章笔记</title>
      <link>http://shamaoxiaogui.github.io/post/cpp_primer_note_4/</link>
      <pubDate>Tue, 19 Jul 2016 21:18:38 +0800</pubDate>
      
      <guid>http://shamaoxiaogui.github.io/post/cpp_primer_note_4/</guid>
      <description>&lt;p&gt;第四章主要是表达式相关的内容：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;除了&lt;code&gt;&amp;amp;&amp;amp; || ?: ,&lt;/code&gt;四种操作符外，其他操作符都没有定义运算顺序（重要）&lt;/li&gt;

&lt;li&gt;&lt;p&gt;sizeof是一种运算符，它不会对表达式进行求值，c++11允许用作用域运算符(::)来获取成员大小而不必提供一个实体（前提是，该成员是public的，活着调用方法是static的），对数组返回数组大小而不是指针大小，对vector和string这种返回其固定部分大小。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;string&amp;gt;
class testc{
public:
    char pwc;
    void update(){}
private:
    char wc;
};
int main(){
    int a=44;
    int ar[5];
    std::string str(&amp;quot;heheda!&amp;quot;);
    std::cout&amp;lt;&amp;lt;&amp;quot;int : &amp;quot;&amp;lt;&amp;lt;sizeof(a)&amp;lt;&amp;lt;&amp;quot; &amp;quot;&amp;lt;&amp;lt;sizeof(int)&amp;lt;&amp;lt;std::endl;
    std::cout&amp;lt;&amp;lt;&amp;quot;int [5]: &amp;quot;&amp;lt;&amp;lt;sizeof(ar)&amp;lt;&amp;lt;&amp;quot; &amp;quot;&amp;lt;&amp;lt;sizeof(int [5])&amp;lt;&amp;lt;std::endl;
    std::cout&amp;lt;&amp;lt;&amp;quot;string :&amp;quot;&amp;lt;&amp;lt;sizeof(str)&amp;lt;&amp;lt;&amp;quot; &amp;quot;&amp;lt;&amp;lt;sizeof(std::string)&amp;lt;&amp;lt;std::endl;
    std::cout&amp;lt;&amp;lt;&amp;quot;class member(char): &amp;quot;&amp;lt;&amp;lt;sizeof(testc::pwc)&amp;lt;&amp;lt;std::endl;
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ ./sizeoftest.out
int : 4 4
int [5]: 20 20
string :24 24
class member(char): 1
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;逗号运算符先算左边再算右边，最后返回右边，若右边结果为左值则返回的也是左值&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;大多数情况下数组退化为指针，有四种例外：decltype、取址运算符（&amp;amp;），sizeof，typeid：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;iostream&amp;gt;
int main(){
    int a[4];
    std::cout&amp;lt;&amp;lt;&amp;quot;int size: &amp;quot;&amp;lt;&amp;lt;sizeof(int)&amp;lt;&amp;lt;std::endl;
    std::cout&amp;lt;&amp;lt;&amp;quot;arr size: &amp;quot;&amp;lt;&amp;lt;sizeof(a)&amp;lt;&amp;lt;std::endl;
    std::cout&amp;lt;&amp;lt;&amp;quot;a[0] addr: &amp;quot;&amp;lt;&amp;lt;&amp;amp;a[0]&amp;lt;&amp;lt;std::endl;
    std::cout&amp;lt;&amp;lt;&amp;quot;a addr: &amp;quot;&amp;lt;&amp;lt;a&amp;lt;&amp;lt;std::endl;
    std::cout&amp;lt;&amp;lt;&amp;quot;&amp;amp;a :&amp;quot;&amp;lt;&amp;lt;&amp;amp;a&amp;lt;&amp;lt;std::endl;
    std::cout&amp;lt;&amp;lt;&amp;quot;&amp;amp;a[0]+1: &amp;quot;&amp;lt;&amp;lt;&amp;amp;a[0]+1&amp;lt;&amp;lt;std::endl;
    std::cout&amp;lt;&amp;lt;&amp;quot;a+1: &amp;quot;&amp;lt;&amp;lt;a+1&amp;lt;&amp;lt;std::endl;
    std::cout&amp;lt;&amp;lt;&amp;quot;&amp;amp;a+1: &amp;quot;&amp;lt;&amp;lt;&amp;amp;a+1&amp;lt;&amp;lt;std::endl;
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ ./arrayaddr.out
int size: 4
arr size: 16
a[0] addr: 0x7fff566947e0
a addr: 0x7fff566947e0
&amp;amp;a :0x7fff566947e0
&amp;amp;a[0]+1: 0x7fff566947e4
a+1: 0x7fff566947e4
&amp;amp;a+1: 0x7fff566947f0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以发现当采取&lt;code&gt;&amp;amp;a+1&lt;/code&gt;这种形式时，与数组首地址相比，并不是单纯加4，而是加4*4，故而大胆推测，&lt;code&gt;&amp;amp;a&lt;/code&gt;的类型为&lt;code&gt;int [4]&lt;/code&gt;（类似二维数组中的一维元素）&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;指针的转换规则：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;0和nullptr可以转换成任意指针（空指针）&lt;/li&gt;
&lt;li&gt;任意非常量指针可以转换成&lt;code&gt;void*&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;任意指针可以转换成&lt;code&gt;const void*&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;显示转换：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;static_cast&lt;/code&gt;就相当于c的强制类型转换&lt;/li&gt;
&lt;li&gt;&lt;code&gt;const_cast&lt;/code&gt;去除底层const属性，但是对转换后的对象（一般是指针，对其指向的对象）写操作是未定义的，而且不能改变变量类型&lt;/li&gt;
&lt;li&gt;&lt;code&gt;reinterpret_cast&lt;/code&gt;最危险的转换，相当于对同一个内存的地址做不同意义的解释（比如把一个int＊解释为一个char＊），依赖于机器&lt;/li&gt;
&lt;li&gt;&lt;code&gt;dynamic_cast&lt;/code&gt;将指向子类的父类型的指针转化为子类型，这个功能也可以由&lt;code&gt;static_cast&lt;/code&gt;来实现，但是dy会在运行时检查父子类关系，而static只会在编译时检查&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>cpp primer 第三章笔记</title>
      <link>http://shamaoxiaogui.github.io/post/cpp_primer_note_3/</link>
      <pubDate>Tue, 19 Jul 2016 17:05:39 +0800</pubDate>
      
      <guid>http://shamaoxiaogui.github.io/post/cpp_primer_note_3/</guid>
      <description>&lt;p&gt;第三章主要讲vector和string&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;string到底是不是以\0结尾的？c++11中规定&lt;strong&gt;&lt;em&gt;是&lt;/em&gt;&lt;/strong&gt;。但是不要依赖这个特性，乖乖的用size()；但是getline的时候换行符确实丢掉了&lt;/li&gt;

&lt;li&gt;&lt;p&gt;auto for循环，注意效率，有些时候auto for效率更高（迭代器最慢～～）&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;chrono&amp;gt;
#include &amp;lt;string&amp;gt;
int main(){
    int n;
    char ch;
    std::cout&amp;lt;&amp;lt;&amp;quot;input n: &amp;quot;;
    std::cin&amp;gt;&amp;gt;n;
    std::cout&amp;lt;&amp;lt;std::endl;
    std::string str(n,&#39;c&#39;);
    std::chrono::high_resolution_clock::time_point t1,t2;
    t1=std::chrono::high_resolution_clock::now();
    for(int i=0;i&amp;lt;n;++i){
        ch=str[i];
    }
    t2=std::chrono::high_resolution_clock::now();
    std::cout&amp;lt;&amp;lt;&amp;quot;for: &amp;quot;&amp;lt;&amp;lt;std::chrono::duration_cast&amp;lt;std::chrono::microseconds&amp;gt;(t2-t1).count()&amp;lt;&amp;lt;&amp;quot; microseconds&amp;quot;&amp;lt;&amp;lt;std::endl;
    t1=std::chrono::high_resolution_clock::now();
    for(auto t:str){
        ch=t;
    }
    t2=std::chrono::high_resolution_clock::now();
    std::cout&amp;lt;&amp;lt;&amp;quot;auto for: &amp;quot;&amp;lt;&amp;lt;std::chrono::duration_cast&amp;lt;std::chrono::microseconds&amp;gt;(t2-t1).count()&amp;lt;&amp;lt;&amp;quot; microseconds&amp;quot;&amp;lt;&amp;lt;std::endl;
    t1=std::chrono::high_resolution_clock::now();
    for(auto &amp;amp;t:str){
        ch=t;
    }
    t2=std::chrono::high_resolution_clock::now();
    std::cout&amp;lt;&amp;lt;&amp;quot;auto&amp;amp; for: &amp;quot;&amp;lt;&amp;lt;std::chrono::duration_cast&amp;lt;std::chrono::microseconds&amp;gt;(t2-t1).count()&amp;lt;&amp;lt;&amp;quot; microseconds&amp;quot;&amp;lt;&amp;lt;std::endl;
    t1=std::chrono::high_resolution_clock::now();
    for(const auto &amp;amp;t:str){
        ch=t;
    }
    t2=std::chrono::high_resolution_clock::now();
    std::cout&amp;lt;&amp;lt;&amp;quot;const auto&amp;amp; for: &amp;quot;&amp;lt;&amp;lt;std::chrono::duration_cast&amp;lt;std::chrono::microseconds&amp;gt;(t2-t1).count()&amp;lt;&amp;lt;&amp;quot; microseconds&amp;quot;&amp;lt;&amp;lt;std::endl;
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ ./fortest.out
input n: 1000000000

for: 9104902 microseconds
auto for: 5651329 microseconds
auto&amp;amp; for: 5445633 microseconds
const auto&amp;amp; for: 5508764 microseconds
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;但是切记范围for不能改变循环序列的大小！！！&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;string的c_str()返回的char*字符串有可能不保证一直有效！！！&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>cpp primer 第二章笔记</title>
      <link>http://shamaoxiaogui.github.io/post/cpp_primer_note_2/</link>
      <pubDate>Tue, 19 Jul 2016 15:16:37 +0800</pubDate>
      
      <guid>http://shamaoxiaogui.github.io/post/cpp_primer_note_2/</guid>
      <description>

&lt;p&gt;第二章主要讲的是基本类型，需要注意的有：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;同一个表达式混用&lt;strong&gt;&lt;em&gt;有符号&lt;/em&gt;&lt;/strong&gt;和&lt;strong&gt;&lt;em&gt;无符号&lt;/em&gt;&lt;/strong&gt;数，会自动转换成&lt;strong&gt;&lt;em&gt;无符号&lt;/em&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;字面值前缀指定字符编码，后缀指定变量大小或种类&lt;/li&gt;

&lt;li&gt;&lt;p&gt;字符串字面值不可修改（因为放在一个只读段中）&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;iostream&amp;gt;
int main(){
    char *str=&amp;quot;heheda!&amp;quot;;
    std::cout&amp;lt;&amp;lt;&amp;quot;before m: &amp;quot;&amp;lt;&amp;lt;str&amp;lt;&amp;lt;std::endl;
    str[3]=&#39;a&#39;;
    std::cout&amp;lt;&amp;lt;&amp;quot;after m: &amp;quot;&amp;lt;&amp;lt;str&amp;lt;&amp;lt;std::endl;
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ ./cstr.out
before m: heheda!
[2]    37400 bus error  ./cstr.out
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;c++11&lt;/code&gt;提供了一种新的*列表初始化*，但是效率么。。。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;string&amp;gt;
#include &amp;lt;vector&amp;gt;
class tc{
public:
    tc(){std::cout&amp;lt;&amp;lt;&amp;quot;ct a class! &amp;quot;&amp;lt;&amp;lt;std::endl;}
    tc(const tc &amp;amp;t){std::cout&amp;lt;&amp;lt;&amp;quot;copy a class!&amp;quot;&amp;lt;&amp;lt;std::endl;}
    tc&amp;amp; operator=(tc &amp;amp;t){std::cout&amp;lt;&amp;lt;&amp;quot;= a class!&amp;quot;&amp;lt;&amp;lt;std::endl; return *this;}
};
int main(){
    tc t1;
    std::cout&amp;lt;&amp;lt;&amp;quot;===============&amp;quot;&amp;lt;&amp;lt;std::endl;
    tc t2(t1);
    std::cout&amp;lt;&amp;lt;&amp;quot;===============&amp;quot;&amp;lt;&amp;lt;std::endl;
    tc t3=t1;
    std::cout&amp;lt;&amp;lt;&amp;quot;===============&amp;quot;&amp;lt;&amp;lt;std::endl;
    tc t4{t1};
    std::cout&amp;lt;&amp;lt;&amp;quot;===============&amp;quot;&amp;lt;&amp;lt;std::endl;
    tc t5={t1};
    std::cout&amp;lt;&amp;lt;&amp;quot;===============&amp;quot;&amp;lt;&amp;lt;std::endl;
    std::vector&amp;lt;tc&amp;gt; tcv{t1,t2,t3};
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ ./initlist.out
ct a class!
===============
copy a class!
===============
copy a class!
===============
copy a class!
===============
copy a class!
===============
copy a class!
copy a class!
copy a class!
copy a class!
copy a class!
copy a class!
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;所以在用容器时不要随便用初始化列表，详细见&lt;a href=&#34;https://segmentfault.com/a/1190000002484690&#34;&gt;这里&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;const相关&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;const变量只能初始化不能赋值（哈士奇都知道）&lt;/li&gt;
&lt;li&gt;不加extern的const变量只能在本文件访问（所以说加了呢）&lt;/li&gt;
&lt;li&gt;const左值引用可以绑定：const变量，非const变量，常量（字面量，这也是std::string的设计，只能将字符串传给const std::string &amp;amp;，而不能传给std::string &amp;amp;），无论如何，常量左值引用意味着不能通过这个引用去修改变量&lt;/li&gt;
&lt;li&gt;顶层const指指针本身的值是常量，底层const则是指针指向的值是常量，故而在函数传参或者复制指针时，顶层const忽略（反正就算你是常量我也只是复制你，后面无论怎么操作也不会修改你），底层const则不能忽略（因为有可能通过复制的指针修改数据）&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;constexpr常量表达式，由编译器帮忙检查；using的别名声明功能（类似typedef—）&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;单纯的auto的推断效果：忽略顶层const，然后把表达式的值算出来是啥类型auto就是啥类型。底层const保留。加const的auto推断出来才是顶层const的，auto &amp;amp;推断出来才是引用&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;decltype基本保留变量的所有属性，尤其是当变量为引用时推断出来的结果也是引用。当其表达式是解引用操作时，结果必为引用，而其跟双括号表达式（加了括号的变量），结果必为引用&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;注意类内初始值的初始化顺序：类内初始值－》构造函数初始化列表－》构造函数体&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;2016-07-21添加&#34;&gt;2016-07-21添加&lt;/h2&gt;

&lt;p&gt;我又回过头来看了一下，关于initializer_list，之前的示例代码中使用的是左值，所以拷贝了两次，但是当我给类添加移动构造函数并使用std::move将其转换为右值后：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;std::cout&amp;lt;&amp;lt;&amp;quot;===============&amp;quot;&amp;lt;&amp;lt;std::endl;
std::vector&amp;lt;tc&amp;gt; tcv3{std::move(t1),std::move(t2),std::move(t3)};
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;===============
move a class!
move a class!
move a class!
copy a class!
copy a class!
copy a class!
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;出现了这种结果。
似乎不太对，按道理来说initializer_list的设计应该是为了方便用临时量来构造一个集合（按我自己的理解），既然是临时量标准库应该提供转移语义，现在看来并没有。其它的情况我找到了stackoverflow上的一个&lt;a href=&#34;http://stackoverflow.com/questions/8193102/initializer-list-and-move-semantics&#34;&gt;讨论&lt;/a&gt;，显然想要手动从里面转移出临时量也不可以，怪怪的感觉&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>cpp primer 第一章笔记</title>
      <link>http://shamaoxiaogui.github.io/post/cpp_primer_note_1/</link>
      <pubDate>Tue, 19 Jul 2016 14:20:39 +0800</pubDate>
      
      <guid>http://shamaoxiaogui.github.io/post/cpp_primer_note_1/</guid>
      <description>&lt;p&gt;第一章只是一个引入，要注意的有：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;std::cin&lt;/code&gt;在读到EOF的情形&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;iostream&amp;gt;
int main(){
    int val;
    while(std::cin&amp;gt;&amp;gt;val){
        std::cout&amp;lt;&amp;lt;val&amp;lt;&amp;lt;&amp;quot; &amp;quot;;
    }
    std::cout&amp;lt;&amp;lt;std::endl;
    std::cout&amp;lt;&amp;lt;&amp;quot;after loop,val= &amp;quot;&amp;lt;&amp;lt;val&amp;lt;&amp;lt;std::endl;
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;测试发现最终结束时，输入C+D(EOF)与输入非数字，最终val的值是不一样的&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;
$ ./istest
1
1 $

after loop,val= 0

$ ./istest
1
1 ^D
    
after loop,val= 1

&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;std::cout,std::cerr,std::clog&lt;/code&gt;的区别&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;iostream&amp;gt;
int main(){
    std::cout&amp;lt;&amp;lt;&amp;quot;from cout&amp;quot;&amp;lt;&amp;lt;std::endl;
    std::clog&amp;lt;&amp;lt;&amp;quot;from clog&amp;quot;&amp;lt;&amp;lt;std::endl;
    std::cerr&amp;lt;&amp;lt;&amp;quot;from cerr&amp;quot;&amp;lt;&amp;lt;std::endl;
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;测试结果：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ ./istest &amp;amp;&amp;amp; echo &amp;quot;======&amp;quot; &amp;amp;&amp;amp; ./istest 2&amp;gt;hehe
from cout
from clog
from cerr
======
from cout
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;总结：
    - cout 标准输出
    - cerr 标准错误
    - clog 标准错误（貌似带缓冲，没验证）&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>about</title>
      <link>http://shamaoxiaogui.github.io/about/</link>
      <pubDate>Sun, 17 Jul 2016 13:46:59 +0800</pubDate>
      
      <guid>http://shamaoxiaogui.github.io/about/</guid>
      <description>&lt;p&gt;Adro，男，西电研狗，私以为生活习性可与草履虫相媲美。&lt;/p&gt;

&lt;p&gt;平时除了调戏女朋友（括弧笑），喜欢嵌入式、撩拨linux、扯扯并发，聊聊服务器。身为一条合格的研狗，坚决执行老板的决定，哪怕老板说：“我们要产品大卖！”嗯，产品大卖。&lt;/p&gt;

&lt;p&gt;厂里，哦不，实验室里主要负责桌面式眼动仪的硬件软件平台设计，一言不合就画板子，写固件，戳USB3.0，码上位机，故而熟悉QT，并发编程，网络通信，熟读程序员腰椎疾病恢复指南。&lt;/p&gt;

&lt;p&gt;遥想当年，意气风发，打过dota，写过合作式调度器，玩过stm32，参加过电赛，如今不过是过眼烟云。&lt;/p&gt;

&lt;p&gt;最后，头像是本人。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>搬家记录</title>
      <link>http://shamaoxiaogui.github.io/post/FirstPost/</link>
      <pubDate>Sun, 17 Jul 2016 13:09:40 +0800</pubDate>
      
      <guid>http://shamaoxiaogui.github.io/post/FirstPost/</guid>
      <description>&lt;p&gt;折腾了一上午，最后还是选择从hexo迁到hugo，记录一下～&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>