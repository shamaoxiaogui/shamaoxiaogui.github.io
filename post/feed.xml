<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on Adro的作死笔记</title>
    <link>http://shamaoxiaogui.github.io/post/</link>
    <description>Recent content in Posts on Adro的作死笔记</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <lastBuildDate>Tue, 19 Jul 2016 17:05:39 +0800</lastBuildDate>
    <atom:link href="http://shamaoxiaogui.github.io/post/feed/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>cpp primer 第三章笔记</title>
      <link>http://shamaoxiaogui.github.io/post/cpp_primer_note_3/</link>
      <pubDate>Tue, 19 Jul 2016 17:05:39 +0800</pubDate>
      
      <guid>http://shamaoxiaogui.github.io/post/cpp_primer_note_3/</guid>
      <description>&lt;p&gt;第三章主要讲vector和string&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;string到底是不是以\0结尾的？c++11中规定&lt;strong&gt;&lt;em&gt;是&lt;/em&gt;&lt;/strong&gt;。但是不要依赖这个特性，乖乖的用size()；但是getline的时候换行符确实丢掉了&lt;/li&gt;

&lt;li&gt;&lt;p&gt;auto for循环，注意效率，有些时候auto for效率更高（迭代器最慢～～）&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;chrono&amp;gt;
#include &amp;lt;string&amp;gt;
int main(){
    int n;
    char ch;
    std::cout&amp;lt;&amp;lt;&amp;quot;input n: &amp;quot;;
    std::cin&amp;gt;&amp;gt;n;
    std::cout&amp;lt;&amp;lt;std::endl;
    std::string str(n,&#39;c&#39;);
    std::chrono::high_resolution_clock::time_point t1,t2;
    t1=std::chrono::high_resolution_clock::now();
    for(int i=0;i&amp;lt;n;++i){
        ch=str[i];
    }
    t2=std::chrono::high_resolution_clock::now();
    std::cout&amp;lt;&amp;lt;&amp;quot;for: &amp;quot;&amp;lt;&amp;lt;std::chrono::duration_cast&amp;lt;std::chrono::microseconds&amp;gt;(t2-t1).count()&amp;lt;&amp;lt;&amp;quot; microseconds&amp;quot;&amp;lt;&amp;lt;std::endl;
    t1=std::chrono::high_resolution_clock::now();
    for(auto t:str){
        ch=t;
    }
    t2=std::chrono::high_resolution_clock::now();
    std::cout&amp;lt;&amp;lt;&amp;quot;auto for: &amp;quot;&amp;lt;&amp;lt;std::chrono::duration_cast&amp;lt;std::chrono::microseconds&amp;gt;(t2-t1).count()&amp;lt;&amp;lt;&amp;quot; microseconds&amp;quot;&amp;lt;&amp;lt;std::endl;
    t1=std::chrono::high_resolution_clock::now();
    for(auto &amp;amp;t:str){
        ch=t;
    }
    t2=std::chrono::high_resolution_clock::now();
    std::cout&amp;lt;&amp;lt;&amp;quot;auto&amp;amp; for: &amp;quot;&amp;lt;&amp;lt;std::chrono::duration_cast&amp;lt;std::chrono::microseconds&amp;gt;(t2-t1).count()&amp;lt;&amp;lt;&amp;quot; microseconds&amp;quot;&amp;lt;&amp;lt;std::endl;
    t1=std::chrono::high_resolution_clock::now();
    for(const auto &amp;amp;t:str){
        ch=t;
    }
    t2=std::chrono::high_resolution_clock::now();
    std::cout&amp;lt;&amp;lt;&amp;quot;const auto&amp;amp; for: &amp;quot;&amp;lt;&amp;lt;std::chrono::duration_cast&amp;lt;std::chrono::microseconds&amp;gt;(t2-t1).count()&amp;lt;&amp;lt;&amp;quot; microseconds&amp;quot;&amp;lt;&amp;lt;std::endl;
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ ./fortest.out
input n: 1000000000

for: 9104902 microseconds
auto for: 5651329 microseconds
auto&amp;amp; for: 5445633 microseconds
const auto&amp;amp; for: 5508764 microseconds
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;但是切记范围for不能改变循环序列的大小！！！&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;string的c_str()返回的char*字符串有可能不保证一直有效！！！&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>cpp primer 第二章笔记</title>
      <link>http://shamaoxiaogui.github.io/post/cpp_primer_note_2/</link>
      <pubDate>Tue, 19 Jul 2016 15:16:37 +0800</pubDate>
      
      <guid>http://shamaoxiaogui.github.io/post/cpp_primer_note_2/</guid>
      <description>&lt;p&gt;第二章主要讲的是基本类型，需要注意的有：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;同一个表达式混用&lt;strong&gt;&lt;em&gt;有符号&lt;/em&gt;&lt;/strong&gt;和&lt;strong&gt;&lt;em&gt;无符号&lt;/em&gt;&lt;/strong&gt;数，会自动转换成&lt;strong&gt;&lt;em&gt;无符号&lt;/em&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;字面值前缀指定字符编码，后缀指定变量大小或种类&lt;/li&gt;

&lt;li&gt;&lt;p&gt;字符串字面值不可修改（因为放在一个只读段中）&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;iostream&amp;gt;
int main(){
    char *str=&amp;quot;heheda!&amp;quot;;
    std::cout&amp;lt;&amp;lt;&amp;quot;before m: &amp;quot;&amp;lt;&amp;lt;str&amp;lt;&amp;lt;std::endl;
    str[3]=&#39;a&#39;;
    std::cout&amp;lt;&amp;lt;&amp;quot;after m: &amp;quot;&amp;lt;&amp;lt;str&amp;lt;&amp;lt;std::endl;
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ ./cstr.out
before m: heheda!
[2]    37400 bus error  ./cstr.out
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;c++11&lt;/code&gt;提供了一种新的*列表初始化*，但是效率么。。。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;string&amp;gt;
#include &amp;lt;vector&amp;gt;
class tc{
public:
    tc(){std::cout&amp;lt;&amp;lt;&amp;quot;ct a class! &amp;quot;&amp;lt;&amp;lt;std::endl;}
    tc(const tc &amp;amp;t){std::cout&amp;lt;&amp;lt;&amp;quot;copy a class!&amp;quot;&amp;lt;&amp;lt;std::endl;}
    tc&amp;amp; operator=(tc &amp;amp;t){std::cout&amp;lt;&amp;lt;&amp;quot;= a class!&amp;quot;&amp;lt;&amp;lt;std::endl; return *this;}
};
int main(){
    tc t1;
    std::cout&amp;lt;&amp;lt;&amp;quot;===============&amp;quot;&amp;lt;&amp;lt;std::endl;
    tc t2(t1);
    std::cout&amp;lt;&amp;lt;&amp;quot;===============&amp;quot;&amp;lt;&amp;lt;std::endl;
    tc t3=t1;
    std::cout&amp;lt;&amp;lt;&amp;quot;===============&amp;quot;&amp;lt;&amp;lt;std::endl;
    tc t4{t1};
    std::cout&amp;lt;&amp;lt;&amp;quot;===============&amp;quot;&amp;lt;&amp;lt;std::endl;
    tc t5={t1};
    std::cout&amp;lt;&amp;lt;&amp;quot;===============&amp;quot;&amp;lt;&amp;lt;std::endl;
    std::vector&amp;lt;tc&amp;gt; tcv{t1,t2,t3};
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ ./initlist.out
ct a class!
===============
copy a class!
===============
copy a class!
===============
copy a class!
===============
copy a class!
===============
copy a class!
copy a class!
copy a class!
copy a class!
copy a class!
copy a class!
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;所以在用容器时不要随便用初始化列表，详细见&lt;a href=&#34;https://segmentfault.com/a/1190000002484690&#34;&gt;这里&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;const相关&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;const变量只能初始化不能赋值（哈士奇都知道）&lt;/li&gt;
&lt;li&gt;不加extern的const变量只能在本文件访问（所以说加了呢）&lt;/li&gt;
&lt;li&gt;const左值引用可以绑定：const变量，非const变量，常量（字面量，这也是std::string的设计，只能将字符串传给const std::string &amp;amp;，而不能传给std::string &amp;amp;），无论如何，常量左值引用意味着不能通过这个引用去修改变量&lt;/li&gt;
&lt;li&gt;顶层const指指针本身的值是常量，底层const则是指针指向的值是常量，故而在函数传参或者复制指针时，顶层const忽略（反正就算你是常量我也只是复制你，后面无论怎么操作也不会修改你），底层const则不能忽略（因为有可能通过复制的指针修改数据）&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;constexpr常量表达式，由编译器帮忙检查；using的别名声明功能（类似typedef—）&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;单纯的auto的推断效果：忽略顶层const，然后把表达式的值算出来是啥类型auto就是啥类型。底层const保留。加const的auto推断出来才是顶层const的，auto &amp;amp;推断出来才是引用&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;decltype基本保留变量的所有属性，尤其是当变量为引用时推断出来的结果也是引用。当其表达式是解引用操作时，结果必为引用，而其跟双括号表达式（加了括号的变量），结果必为引用&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;注意类内初始值的初始化顺序：类内初始值－》构造函数初始化列表－》构造函数体&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>cpp primer 第一章笔记</title>
      <link>http://shamaoxiaogui.github.io/post/cpp_primer_note_1/</link>
      <pubDate>Tue, 19 Jul 2016 14:20:39 +0800</pubDate>
      
      <guid>http://shamaoxiaogui.github.io/post/cpp_primer_note_1/</guid>
      <description>&lt;p&gt;第一章只是一个引入，要注意的有：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;std::cin&lt;/code&gt;在读到EOF的情形&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;iostream&amp;gt;
int main(){
    int val;
    while(std::cin&amp;gt;&amp;gt;val){
        std::cout&amp;lt;&amp;lt;val&amp;lt;&amp;lt;&amp;quot; &amp;quot;;
    }
    std::cout&amp;lt;&amp;lt;std::endl;
    std::cout&amp;lt;&amp;lt;&amp;quot;after loop,val= &amp;quot;&amp;lt;&amp;lt;val&amp;lt;&amp;lt;std::endl;
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;测试发现最终结束时，输入C+D(EOF)与输入非数字，最终val的值是不一样的&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;
$ ./istest
1
1 $

after loop,val= 0

$ ./istest
1
1 ^D
    
after loop,val= 1

&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;std::cout,std::cerr,std::clog&lt;/code&gt;的区别&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;iostream&amp;gt;
int main(){
    std::cout&amp;lt;&amp;lt;&amp;quot;from cout&amp;quot;&amp;lt;&amp;lt;std::endl;
    std::clog&amp;lt;&amp;lt;&amp;quot;from clog&amp;quot;&amp;lt;&amp;lt;std::endl;
    std::cerr&amp;lt;&amp;lt;&amp;quot;from cerr&amp;quot;&amp;lt;&amp;lt;std::endl;
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;测试结果：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ ./istest &amp;amp;&amp;amp; echo &amp;quot;======&amp;quot; &amp;amp;&amp;amp; ./istest 2&amp;gt;hehe
from cout
from clog
from cerr
======
from cout
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;总结：
    - cout 标准输出
    - cerr 标准错误
    - clog 标准错误（貌似带缓冲，没验证）&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>搬家记录</title>
      <link>http://shamaoxiaogui.github.io/post/FirstPost/</link>
      <pubDate>Sun, 17 Jul 2016 13:09:40 +0800</pubDate>
      
      <guid>http://shamaoxiaogui.github.io/post/FirstPost/</guid>
      <description>&lt;p&gt;折腾了一上午，最后还是选择从hexo迁到hugo，记录一下～&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>