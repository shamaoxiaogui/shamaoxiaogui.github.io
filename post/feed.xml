<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on Adro的作死笔记</title>
    <link>http://shamaoxiaogui.github.io/post/</link>
    <description>Recent content in Posts on Adro的作死笔记</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <lastBuildDate>Tue, 26 Jul 2016 14:32:39 +0800</lastBuildDate>
    <atom:link href="http://shamaoxiaogui.github.io/post/feed/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>aggregates and pod</title>
      <link>http://shamaoxiaogui.github.io/post/aggregates_and_pod/</link>
      <pubDate>Tue, 26 Jul 2016 14:32:39 +0800</pubDate>
      
      <guid>http://shamaoxiaogui.github.io/post/aggregates_and_pod/</guid>
      <description>

&lt;p&gt;这篇文章大部分整理自stackoverflow上的一篇&lt;a href=&#34;http://stackoverflow.com/questions/4178175/what-are-aggregates-and-pods-and-how-why-are-they-special&#34;&gt;讨论&lt;/a&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;还记得数组的花括号赋值么？还记得c语言中简单的结构体么？还记得c语言初始化结构体用的memset和bzero么？还记得通过socket发送结构体是怎么实现的么？这些就是cpp中aggregate和pod想要做到的。&lt;/p&gt;

&lt;h2 id=&#34;aggregate&#34;&gt;Aggregate&lt;/h2&gt;

&lt;p&gt;要解释POD(Plain Old Data)，就要首先来说一下aggregate。再进入细节之前先说一下aggregate能做什么。aggregate可以用花括号初始化～～，是的，就这么简单。再深一点，它翻译成中文就是聚合，就是说把一堆成员放到一起，并没有面向对象思想中对象的概念，它只是一个数据集合。
接下来看下它的定义，首先看下primer5th中的定义：&lt;/p&gt;

&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;所有成员都是public的&lt;/li&gt;
&lt;li&gt;没有定义任何构造函数&lt;/li&gt;
&lt;li&gt;没有类内初始值&lt;/li&gt;
&lt;li&gt;没有基类和virtual函数&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;03标准的定义&#34;&gt;03标准的定义&lt;/h2&gt;

&lt;p&gt;这些定义实际上柔和类c++11标准在里面，我们先看03标准的表述：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;An aggregate is an array or a class (clause 9) with no user-declared constructors (12.1), no private or protected non-static data members (clause 11), no base classes (clause 10), and no virtual functions (10.3).&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;然后来把这段话拆开：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;数组一定是aggregate的（哪怕里面放的数据成员不是aggregate的）&lt;/li&gt;
&lt;li&gt;aggregate类（标准中的class可以指class和struct以及union）不能有用户声明的构造函数（包括默认、拷贝和移动，以及其它任何构造函数）&lt;/li&gt;
&lt;li&gt;aggregate类的非静态成员必须都是public的（静态成员就无所谓了）&lt;/li&gt;
&lt;li&gt;aggregate类没有基类和虚函数。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;好嘛，这么多，原谅我的脑容量。其实很好理解，之前说过，aggregate这个概念就是为了表明数据的聚集体，那么数组自然就是数据的聚集体，而对于一个类来说，它的数据只有非静态数据成员，而静态数据成员、成员函数等等实际上都可以看作是对这个类定义的操作。有点绕口也有些抽象，那么我们就来逐条看下这些要求。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;不能有任何用户定义的构造函数。如果有会怎么样？如果有的话编译器就会认为你这个类不能“简单的”初始化了,就是说编译器会觉得你这个类可能还会需要分配空间意外的其它操作，这就跟“聚合”这个概念不符了。（即使是定义了一个鸡毛都不干的默认构造函数都不行！！！虽然感觉这样也不破坏聚合的概念）&lt;/li&gt;
&lt;li&gt;非静态成员都是public的，如果是private和protected的话，亲，你要访问数据成员还得定义接口啊。。。虽然也可以，但是，编译器不知道啊，后面还会讨论花括号赋值的内容会继续说这点。&lt;/li&gt;
&lt;li&gt;不能有基类和虚函数。基类和虚函数都会在一定程度上破坏聚合的概念，更重要的，它们的存在会迫使编译器生成“不简单”（实际上是notrivial）的合成默认构造函数，详见《深入理解c++对象模型》&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;ok，这三条大致分析了一下，接下来我们看一下aggregate类的使用。还记得我们说数组一定是aggregate的对吧，那就先想想数组怎么初始化：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;type array[m]={a1,a2,a3...an};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;那么，针对m和n，我们有如下分析：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;if m == n
    array数组中完美的存放a1到an这些元素
elseif m &amp;gt; n
    array数组中的前n个空间存放a1到an，后面的元素执行值初始化（也就是会调用它们的默认构造函数）
else （这时候就是a[]={a1...an}的情形）
    这时候没有显示声明array的大小，它会按照元素的数量（n）来定义一个数组存放a1到an
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;那么我们说aggregate类也是数据的聚集，也可以使用花括号来赋值，类比数组，看一下下面这个例子：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;struct X
{
  int i1;
  int i2;
};
struct Y
{
  char c;
  X x;
  int i[2];
  float f; 
protected:
  static double d;
private:
  void g(){}      
}; 

Y y = {&#39;a&#39;, {10, 20}, {20, 30}};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面的例子当中，对于Y，其数据元素除了最后一个float f，其它都有初始值，而f则进行了默认初始化。其子类x也是一个aggregate类，所以可以由嵌套的花括号初始化。现在你想，如果成员不是public的，这种初始化能行么。。。。
例子：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;iostream&amp;gt;
class noaggregate{
    int x;
};
struct aggregate{};
struct noaggregate1{
    noaggregate1(){};
    int n;
};
struct aggregate1{
    aggregate1&amp;amp; operator=(const aggregate&amp;amp;){return *this;}
    ~aggregate1(){}
    double d;
private:
    static int hehe;
};
int main(){
    // noaggregate ng={1}; //err: no matching ctor
    noaggregate ng; //ok
    // noaggregate1 ng1={2};//err: no matching ctor
    noaggregate1 ng1; //ok
    aggregate1 ag1={3.14}; //ok
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最后，我们来对标准定义进行小小的探索。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;不能有任何&lt;strong&gt;&lt;em&gt;显示定义的&lt;/em&gt;&lt;/strong&gt;构造函数，但是可以有&lt;strong&gt;&lt;em&gt;显式声明的拷贝赋值运算符&lt;/em&gt;&lt;/strong&gt;，以及&lt;strong&gt;&lt;em&gt;显示的析构函数&lt;/em&gt;&lt;/strong&gt;，同时，如果一个类中有引用类型的成员，或者const成员，那必然需要一个显式的构造函数，所以不能有这两种成员。（而且注意到，对于含有非静态成员的类而言，如果不提供显示的默认构造函数，是不能定义一个该类的const对象的，因为所有const变量都需要在定义时初始化）&lt;/li&gt;
&lt;li&gt;非静态成员必须是public的，但是你可以有各种访问控制（public、private、protected）的成员函数和静态成员&lt;/li&gt;
&lt;li&gt;注意了，对数组而言，其元素是不是aggregate不影响数组的aggregate属性，同样，类的成员（不管静态还是非静态）是不是aggregate也不会影响它的aggregate属性。(非aggregate没有“感染性”)&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;这就是03标准对aggregate的定义了，aggregate实现了c语言中对结构体的花括号赋值，更重要的是它提供了一种数据集合的概念。&lt;/p&gt;

&lt;h3 id=&#34;11标准对aggregate定义的改进&#34;&gt;11标准对aggregate定义的改进&lt;/h3&gt;

&lt;p&gt;先来看下11标准中的定义：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;An aggregate is an array or a class (Clause 9) with no user-provided constructors (12.1), no brace-or-equal-initializers for non-static data members (9.2), no private or protected non-static data members (Clause 11), no base classes (Clause 10), and no virtual functions (10.3).
不一样的地方主要有两点：&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;现在不能有user-provided constructors，之前是不能有user-declared constructors。有什么区别呢？主要是因为11标准引入了主动声明使用编译器合成的构造函数机制。所以现在可以这样用了：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;struct X{
    X()=default;
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个声明是说使用编译器合成的默认构造函数，但是它确实是user-declared constructors。。所以新标准在这里进行了改动，允许这种用法在aggregate类中存在。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;非静态成员不能有brace-or-equal-initializers。什么叫brace-or-equal-initializers呢，看下面这个例子：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;struct Y{
    int x=2;
    double d=3.14;
    char ch{&#39;x&#39;};
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;懂了吧。。。11标准引入了类内初始值的概念，可以对类成员使用＝或大括号进行类内初始化，实际上最终编译器也会将其作为构造函数的一部分，所以不能有这些。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;现在，你可以回过头去对照primer5th提供的定义再好好的研究下aggregate类了，它将是我们下面所要探索的POD类型的基础。&lt;/p&gt;

&lt;h2 id=&#34;pod&#34;&gt;POD&lt;/h2&gt;

&lt;p&gt;还记得我们在开篇时提到的那几个问题么，关于c的结构体的那几个。好吧，现在假设我们需要用c++来实现一个功能，这个功能作为某个大型软件工程的扩展，而这个工程又是c写的，它传给我们的数据是一个c的结构体，要求我们传回的也是一个c结构体怎么办？好吧，我知道你们有更好更聪明的办法，但是这里我们采用c++的POD类型来解决。
假设我们认可POD类的这个功能，就是可以用来作为导出给c的接口，我们来试着逆推一下POD的特性：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;应该可以实现像c的结构体一样的复制能力，比如同类型不同实例结构体之间的复制（不考虑指针复制带来的内存管理问题）这种复制应该是位逐次复制（bitwise copy，相对于memberwise copy）&lt;/li&gt;
&lt;li&gt;应该有和“同样声明”的c结构体一样的内存布局，这样c才能用memcpy来拷贝它。（就好像将一个结构体序列化写入一个文件，再从这个文件中序列化读出一样，主角必须要有相同的内存分布，否则对数据的解读就会出错）。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;那么，看一下aggregate类是否满足这些条件，因为如果它满足了，我们还要POD干嘛。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;同类型的复制。还记得我们在之前说过aggregate类中可以定义赋值运算符么。。。。&lt;/li&gt;
&lt;li&gt;内存布局。还记得我们说aggregate类的成员可以是非aggregate的么。。。。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;所以aggregate类是不满足这些条件的，但是我们发现满足这些条件的一定是aggregate类（这里大家不要纠结非静态成员变量的访问权限是不是public这个问题，后面11标准也进行了相应的改进。至于其它条件，c的结构体本身就是符合位逐次复制机制的，所以相对应满足上面第一个条件的类也应该是位逐次复制机制，这种类只有用户不显示的定义任何构造函数编译器才会为其产生相应机制的默认构造函数和赋值构造函数。而对于虚函数与基类，研究过c++对象模型的同学应该会清楚它们对类内存布局的一些影响，所以也不详谈），也就是说POD类也是aggregate类。
这里列出的两点只是为了让大家有一个感性上的认识，接下来才是严格的定义。&lt;/p&gt;

&lt;h2 id=&#34;03标准的定义-1&#34;&gt;03标准的定义&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;A POD-struct is an aggregate class that has no non-static data members of type non-POD-struct, non-POD-union (or array of such types) or reference, and has no user-defined copy assignment operator and no user-defined destructor. Similarly, a POD-union is an aggregate union that has no non-static data members of type non-POD-struct, non-POD-union (or array of such types) or reference, and has no user-defined copy assignment operator and no user-defined destructor. A POD class is a class that is either a POD-struct or a POD-union.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;blablabla&amp;hellip;呵呵，读的我尴尬症都犯了。同样，还是来拆开看：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;POD类是一种aggregate类&lt;/li&gt;
&lt;li&gt;POD类的非静态成员不能有非POD类型，不能有含有非POD类型的数组，不能有引用&lt;/li&gt;
&lt;li&gt;POD类不能有用户定义的赋值运算符和析构函数&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;哦，又到了发散思维抠字眼的时候了，首先我们很高兴，因为我们的推断是正确的：POD类都是aggregate的。接下来看后面两条：&lt;/p&gt;

&lt;p&gt;1.
不能有非POD类型的成员。之前我们说非aggregate是没有“感染性”的，那么非POD就是有感染性的。就是说如果一个类的某个成员非POD，那么这个类也必然非POD。为什么要做这样的要求呢？我们可以这样理解，非POD类，要么没有一个兼容c结构体的内存布局（这会导致它“组成”的类的布局也与传统的c结构体不兼容，比如虚表指针、虚基类都是不兼容的因素），要么就不能执行位逐次拷贝或者notrivial（这会导致编译器生成trivial的构造函数失败，影响位逐次拷贝机制，详见《深入理解c++对象模型》），要么两者兼而有之，所以才有这条限制。
1. 不能有用户提供的赋值运算符和析构函数。用户提供了这些，就意味着类中的成员需要资源管理，传统的c结构体可是没有这个概念的。或者仍然可以从位逐次拷贝机制来理解。&lt;/p&gt;

&lt;p&gt;例子：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;struct POD
{
  int x;
  char y;
  void f() {} //no harm if there&#39;s a function
  static std::vector&amp;lt;char&amp;gt; v; //static members do not matter
};

struct AggregateButNotPOD1
{
  int x;
  ~AggregateButNotPOD1() {} //user-defined destructor
};

struct AggregateButNotPOD2
{
  AggregateButNotPOD1 arrOfNonPod[3]; //array of non-POD class
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;那么POD类型的特性：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;POD可以用做向c活着.net导出数据的数据结构&lt;/li&gt;
&lt;li&gt;POD的生命周期始于空间分配，终于空间回收；而非POD则始于构造完成，终于析构开始。（POD没有显示定义的dctor的原因）&lt;/li&gt;
&lt;li&gt;POD可以使用memcpy、memset等函数，保证memcpy拷贝给一块足够大的内存再拷贝回来其数据不变&lt;/li&gt;

&lt;li&gt;&lt;p&gt;c++不允许goto从一个还未定义某个变量的作用域跳过一个变量的定义而进入它的作用域，但是POD可以：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;int f()
{
  struct NonPOD {NonPOD() {}};
  goto label;
  NonPOD x;     //bad
label:
  return 0;
}

int g()
{
  struct POD {int i; char c;};
  goto label;
  POD x;    //ok
label:
  return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;POD保证其内存开始处不会有padding（因为没有基类虚函数而且成员都是POD的，而aggregate虽然也没有基类虚函数，但是有可能第一个成员是非aggregate的带虚函数的类，那仍然会有padding），这样对于一个POD类A，它的第一个成员为T，可以使用reinterpret_cast完成A*与T*的转化。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;11标准对pod类定义的改进&#34;&gt;11标准对POD类定义的改进&lt;/h3&gt;

&lt;p&gt;好吧，终于到最后了。11标准对POD类的定义改动还是比较大的，但整体上来说是放宽了限制。
11标准中，POD类被定义为需要满足以下两条特性：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;支持静态初始化（静态初始化，可以简单理解为，一个放在data段的（全局或着静态）数据，在进程运行前，其初始化的值可以由操作系统直接从可执行文件镜像中加载到内存，虽然可能不太准确但是可以这样粗略理解）。&lt;/li&gt;
&lt;li&gt;POD类在c++中编译出的内存布局与在c中编译出的内存布局相同&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;所以相对应的POD类被拆分为trivial和Standard-layout两部分。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;trivial类支持静态初始化，其要求有：&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
&lt;p&gt;A trivially copyable class is a class that:&lt;/p&gt;

&lt;p&gt;— has no non-trivial copy constructors (12.8),&lt;/p&gt;

&lt;p&gt;— has no non-trivial move constructors (12.8),&lt;/p&gt;

&lt;p&gt;— has no non-trivial copy assignment operators (13.5.3, 12.8),&lt;/p&gt;

&lt;p&gt;— has no non-trivial move assignment operators (13.5.3, 12.8), and&lt;/p&gt;

&lt;p&gt;— has a trivial destructor (12.4).&lt;/p&gt;

&lt;p&gt;A trivial class is a class that has a trivial default constructor (12.1) and is trivially copyable.&lt;/p&gt;

&lt;p&gt;[ Note: In particular, a trivially copyable or trivial class does not have virtual functions or virtual base classes.—end note ]&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;那么trivial与nontrivial的区别：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;A copy/move constructor for class X is trivial if it is not user-provided and if&lt;/p&gt;

&lt;p&gt;— class X has no virtual functions (10.3) and no virtual base classes (10.1), and&lt;/p&gt;

&lt;p&gt;— the constructor selected to copy/move each direct base class subobject is trivial, and&lt;/p&gt;

&lt;p&gt;— for each non-static data member of X that is of class type (or array thereof), the constructor selected to copy/move that member is trivial;&lt;/p&gt;

&lt;p&gt;otherwise the copy/move constructor is non-trivial.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
&lt;li&gt;而Standard-layout则满足第二个特性&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
&lt;p&gt;A standard-layout class is a class that:&lt;/p&gt;

&lt;p&gt;— has no non-static data members of type non-standard-layout class (or array of such types) or reference,&lt;/p&gt;

&lt;p&gt;— has no virtual functions (10.3) and no virtual base classes (10.1),&lt;/p&gt;

&lt;p&gt;— has the same access control (Clause 11) for all non-static data members,&lt;/p&gt;

&lt;p&gt;— has no non-standard-layout base classes,&lt;/p&gt;

&lt;p&gt;— either has no non-static data members in the most derived class and at most one base class with non-static data members, or has no base classes with non-static data members, and&lt;/p&gt;

&lt;p&gt;— has no base classes of the same type as the first non-static data member.&lt;/p&gt;

&lt;p&gt;A standard-layout struct is a standard-layout class defined with the class-key struct or the class-key class.&lt;/p&gt;

&lt;p&gt;A standard-layout union is a standard-layout class defined with the class-key union.&lt;/p&gt;

&lt;p&gt;[ Note: Standard-layout classes are useful for communicating with code written in other programming languages. Their layout is specified in 9.2.—end note ]&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;详细的解释见文章开头的链接。主要注意是，11标准放宽类限制，现在所有成员只要有相同的访问控制就好了（因为之前的标准对不同访问控制的成员内存分布没有做限定，这样可以防止成员的不连续存放）。再者，禁止第一个非静态成员和基类类型相同，是因为如果类的第一个非静态成员与基类类型相同，它们会共享相同的地址。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>深入理解cpp对象模型 第四章笔记</title>
      <link>http://shamaoxiaogui.github.io/post/inside_cpp_object_model_ch4/</link>
      <pubDate>Tue, 26 Jul 2016 10:31:23 +0800</pubDate>
      
      <guid>http://shamaoxiaogui.github.io/post/inside_cpp_object_model_ch4/</guid>
      <description>&lt;p&gt;第四章主要是对成员函数的讲解：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;对于static成员函数：

&lt;ol&gt;
&lt;li&gt;不可以直接存取nonstatic成员&lt;/li&gt;
&lt;li&gt;不可以是const限定的&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;对于非静态成员函数的处理：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;在函数签名（函数名，参数数量，参数类型）中添加一个新参数，this指针。&lt;/li&gt;
&lt;li&gt;将其中对非静态成员的存取改为this指针操作&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;struct Someclass{
    void func(){n+=3;}
    int n;
};
Someclass::func();
//expand to
void func(Someclass *const this){ //magic here
    this-&amp;gt;n+=3;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意到扩展出的this是一个const的指针，也就是说在非静态成员函数中我们不能修改传入的this指针。同样，如果非静态成员函数是const限定的，那么传入的const会同时有顶层和底层const属性，也就限定了函数不得修改this和this指向的类。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>深入理解cpp对象模型 第三章笔记</title>
      <link>http://shamaoxiaogui.github.io/post/inside_cpp_object_model_ch3/</link>
      <pubDate>Sun, 24 Jul 2016 11:10:27 +0800</pubDate>
      
      <guid>http://shamaoxiaogui.github.io/post/inside_cpp_object_model_ch3/</guid>
      <description>&lt;p&gt;前言描述了一个很有趣的问题，下面的类X，Y，Z，和A的sizeof各是多大？&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;iostream&amp;gt;
struct X{};
struct Y:public virtual X{};
struct Z:public virtual X{};
struct A:public Y,public Z{};
int main(){
    std::cout&amp;lt;&amp;lt;&amp;quot;X: &amp;quot;&amp;lt;&amp;lt;sizeof(X)&amp;lt;&amp;lt;std::endl;
    std::cout&amp;lt;&amp;lt;&amp;quot;Y: &amp;quot;&amp;lt;&amp;lt;sizeof(Y)&amp;lt;&amp;lt;std::endl;
    std::cout&amp;lt;&amp;lt;&amp;quot;Z: &amp;quot;&amp;lt;&amp;lt;sizeof(Z)&amp;lt;&amp;lt;std::endl;
    std::cout&amp;lt;&amp;lt;&amp;quot;A: &amp;quot;&amp;lt;&amp;lt;sizeof(A)&amp;lt;&amp;lt;std::endl;
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ ./sizeof.out
X: 1
Y: 8
Z: 8
A: 16
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们来分析一下。首先，注意到上面三个类都是所谓的空类，就是没有数据成员的。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;对于A，确实是个空类，没有虚函数意味着没有虚表指针，没有继承关系也不需要编译器添加特别的数据部分。这时他的大小是1个字节，因为为了使A的不同实例有不同的地址，所以编译器对其进行了小填充。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;struct A{
    char _ch;
};
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;对于X和Y，其实并不是完全的空类。虽然没有虚表指针，但是它们虚继承了A，所以编译器必然会给它们添加一些成员：添加一个指针，指向虚基类或一个表格，表格中存放虚基类的地址或者其偏移量。我们来分析下这种做法。我用的mac是64位机，也就是指针大小为8字节，那么Y／Z的大小为&lt;code&gt;8(virtual base pointer)+1(virtual base class)+7(alignment padding)=16bytes&lt;/code&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;struct Y{
    void *vbtr;     //to A, 8bytes
    A aa;   //1byte
    //padding 7bytes
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;而结果为8byte与我们的计算不复。这里实际上编译器执行了一种优化：空虚基类（empty virtual base class ）通常用于提供一个virtual interface，那就将这种基类当作优化为派生类的数据成员好了，也就是直接将它放到派生类的开头部分，不再需要用虚基类指针指向它。这样的话，之前“空”的派生类现在“有”了一个成员，那么就没有必要给他添加1byte来区分类的不同对象，也就是将上面第一条的1个字节给省掉了，那么也就不需要最后7个字节的alignment padding了，而需要的是对虚基类占用空间的padding。所以大小为&lt;code&gt;1(virtual base class)+7(alignment padding)=8bytes&lt;/code&gt;。反过来，如果X中原本就有数据成员，就不会出现这种编译器优化差异。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;struct Y{
    A aa;   //1byte
    //padding 7bytes
};
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;最后来看A，记住在继承链中不论出现多少次，虚基类只有一个实体。假设编译器没有优化：&lt;code&gt;8(vbtr in Y)+8(vbtr in X)+1(virtual base class)+7(alignment padding)=24bytes&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;struct A{
    void *vbtr_Y;   //vbtr in Y, 8bytes
    void *vbtr_X;   //vbtr in X, 8bytes
    A aa;   //virtual base class, 1byte
    //padding 7bytes
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;而进行优化后，大小为&lt;code&gt;8(Y)+8(Z)=16bytes&lt;/code&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;struct A{
    Y yy;   // 8bytes
    Z zz;   // 8bytes
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;现代C++标准对类的成员函数的解析，是在对类的解析完成后才开始的。所以，将类成员声明在成员函数之后，对成员函数中调用这些成员的语义没什么影响，但是，成员函数的签名却是按顺序解析的，即在类完全解析完之前，成员函数签名就解析完了，这有可能带来如下的影响：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;typedef int length;
extern int x;
struct someclass{
    //...
    length func(){return x;} //这里编译器对x的解读是没问题的，因为到类解析完编译器才会解析成员函数的内容。但是对于声明中的length就不是这样了，它会按顺序解析，也就会把length解析为int
    //...
private:
    typedef double length;
    length x;
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;所以，&lt;strong&gt;&lt;em&gt;永远把类要用到的typrdef放到类声明的起始处&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;对于类中的数据成员，标准只规定，同一access section（private。。。）中靠后的数据成员地址高，并没有说一定要连续。所以有时为了内存对齐，成员直接会有padding。静态成员不管声明在哪都不会占空间。vptr的位置视编译器而定，大多放在类的开始。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;类的成员的存取。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;静态成员，静态成员存储在全局区，所以类的继承关系、访问权限、指针还是对象访问，用类直接访问还是用对象访问对其访问效率都没有影响。要注意的是下面亮点：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;见如下代码：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;foobar().chunkSize=500;
//
(void)foobar();
Point3d.chunkSize=500;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;编译器会进行如上变换。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;如果两个不同的类都声明了同名的静态成员，那么编译器会进行name-mangling，变换齐名称&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;非静态成员：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;origin._y=0.0;
//
*(&amp;amp;origin+(&amp;amp;Point3d::_y-1))=0.0;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里编译器会进行地址的转化，转化为类的地址加上成员的偏移地址。之所以要减一，是因为类成员指针总是指向类成员加一的位置，这样就可以区分一个类成员指针没有指向任何一个成员的情况。
对于如下代码：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;origin.x=0.0;
pt-&amp;gt;x=0.0;  //pt=&amp;amp;origin
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在通常，执行效率没有任何不同，但是，如果origin是一个虚拟继承的派生类，并且x是派生类的成员，这时效率就会有重大差异。因为在编译时不知道pt中存放的具体是哪种类型，就无法用静态地址去替换它，只能依靠一些动态手段（vptr、vbtr）；而origin的类型是可以确定的，编译器会解析出它的静态地址。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;继承时的布局。一般是派生类扩展基类，虚表指针放在顶部。多继承时，内存上先放第一个基类，再放第二个。。。涉及到虚基类，记住虚基类只有一个实体，直接继承虚基类的派生类会有虚基类指针，指向虚基类或者是其偏移量。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;关于成员存取的效率，也许对于虚拟继承基类中成员的存取会慢一点，但是现代编译器的优化都做的比较好，问题不大。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;最后，类成员指针总是存储的是成员在类内的偏移量，书上说这个偏移量还会加一，以区分其不指向对象的情况，但是g++测试表面编译器对此进行了内部优化，使其直接表示偏移量。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;cstdio&amp;gt;
struct sc{
    virtual void func(){}
    char ch;
    int x;
};
int main(){
    sc scc;
    printf(&amp;quot;&amp;amp;scc.ch %p\n&amp;quot;,&amp;amp;scc.ch);
    printf(&amp;quot;&amp;amp;scc.x %p\n&amp;quot;,&amp;amp;scc.x);
    printf(&amp;quot;sc::ch %p\n&amp;quot;,&amp;amp;sc::ch);
    printf(&amp;quot;sc::x %p\n&amp;quot;,&amp;amp;sc::x);
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ ./classptr.out
&amp;amp;scc.ch 0x7fff5d4b37f0
&amp;amp;scc.x 0x7fff5d4b37f4
sc::ch 0x8
sc::x 0xc
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>深入理解cpp对象模型 第二章笔记</title>
      <link>http://shamaoxiaogui.github.io/post/inside_cpp_object_model_ch2/</link>
      <pubDate>Sat, 23 Jul 2016 09:44:58 +0800</pubDate>
      
      <guid>http://shamaoxiaogui.github.io/post/inside_cpp_object_model_ch2/</guid>
      <description>

&lt;p&gt;构造函数部分：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;先复习下primer对合成默认构造函数的叙述：

&lt;ol&gt;
&lt;li&gt;构造函数不能使用const限定符，一个const对象直到构造函数完成时才获得其“常量”属性。&lt;/li&gt;
&lt;li&gt;编译器只有发现类不包含任何构造函数的情况下才会生成一个默认构造函数。&lt;/li&gt;
&lt;li&gt;如果类中包含没有默认构造函数的类成员，就无法生成合成默认构造函数。&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;inside中，一个没有任何构造函数的类会有一个隐式声明的trivial（没啥用的）构造函数，在以下情况则会有nontrivial（有用的，编译器所需要的，我的理解是，就是我们通常说的合成默认构造函数）&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;如果一个类没有任何构造函数且所有的类成员都有默认构造函数，那么编译器会合成一个默认构造函数（在需要的时候，也就如果在代码中实际定义类的实体才会生成），按类成员的声明顺序来调用它们的默认构造函数。而内置变量成员的初始化则是程序员的责任。如果程序员提供了一个构造函数，来进行内置成员变量的初始化，则编译器会按照上述规则扩充这个函数。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;iostream&amp;gt;
using namespace std;
class c1{
public:
    c1(){cout&amp;lt;&amp;lt;&amp;quot;c1 ctor&amp;quot;&amp;lt;&amp;lt;endl;}
    c1(const c1&amp;amp;){cout&amp;lt;&amp;lt;&amp;quot;c1 copy ctor&amp;quot;&amp;lt;&amp;lt;endl;}
};
class c2{
public:
    c2(){cout&amp;lt;&amp;lt;&amp;quot;c2 ctor&amp;quot;&amp;lt;&amp;lt;endl;}
    c2(const c2&amp;amp;){cout&amp;lt;&amp;lt;&amp;quot;c2 copy ctor&amp;quot;&amp;lt;&amp;lt;endl;}
    virtual ~c2(){}
};
class c3{
public:
    c2 cc2;
    c1 cc1;
    char *str;
};
class c4{
public:
    c4(){cout&amp;lt;&amp;lt;&amp;quot;c4 ctor&amp;quot;&amp;lt;&amp;lt;endl;n=1;}
    c4(const c4&amp;amp;){cout&amp;lt;&amp;lt;&amp;quot;c4 copy ctor&amp;quot;&amp;lt;&amp;lt;endl;}
    c2 cc2;
    c1 cc1;
    int n;
};
int main(){
    c3 cc3;
    cout&amp;lt;&amp;lt;&amp;quot;===========================&amp;quot;&amp;lt;&amp;lt;endl;
    c4 cc4;
    cout&amp;lt;&amp;lt;&amp;quot;===========================&amp;quot;&amp;lt;&amp;lt;endl;
    c4 cc5(cc4);
    cout&amp;lt;&amp;lt;&amp;quot;sizeof c1 &amp;quot;&amp;lt;&amp;lt;sizeof(c1)&amp;lt;&amp;lt;endl;
    cout&amp;lt;&amp;lt;&amp;quot;sizeof c2 &amp;quot;&amp;lt;&amp;lt;sizeof(c2)&amp;lt;&amp;lt;endl;
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ ./classctor.out
c2 ctor
c1 ctor
===========================
c2 ctor
c1 ctor
c4 ctor
===========================
c2 ctor
c1 ctor
c4 copy ctor
sizeof c1 1
sizeof c2 8
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以发现（调皮的我顺路测试了下空类的大小），编译器确实扩展了程序员编写的构造函数(即使是拷贝构造函数，编译器扩展时活着生成时也是调用类成员的默认构造函数)。另外，为了防止在多个文件（编译模块）中生成多个默认构造函数，编译器&lt;strong&gt;&lt;em&gt;把合成的默认构造函数、拷贝构造函数、析构函数，拷贝赋值运算符都以inline的方式完成&lt;/em&gt;&lt;/strong&gt;，因为inline函数只在当前文件作用域有效，如果函数太复杂，就合成为static非inline函数。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;如果一个没有任何构造函数的子类的父类有默认构造函数，那么编译器会合成一个调用父类默认构造函数的合成默认构造函数。如果程序员提供了构造函数，但是没有提供默认构造函数，编译器不会合成一个默认构造函数，但是会扩展所有的构造函数，调用父类的默认构造函数。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;iostream&amp;gt;
using namespace std;
class father{
public:
    father(){cout&amp;lt;&amp;lt;&amp;quot;father ctor&amp;quot;&amp;lt;&amp;lt;endl;}
};
class son:public father{
public:
    int n;
};
class son2:public father{
public:
    son2(int x){n=x;cout&amp;lt;&amp;lt;&amp;quot;son2 ctor&amp;quot;&amp;lt;&amp;lt;endl;}
    int n;
};
int main(){
    son s;
    cout&amp;lt;&amp;lt;&amp;quot;====================&amp;quot;&amp;lt;&amp;lt;endl;
    // son2 s2; //error
    cout&amp;lt;&amp;lt;&amp;quot;====================&amp;quot;&amp;lt;&amp;lt;endl;
    son2 s3(3);
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ ./fatherctor.out
father ctor
====================
====================
father ctor
son2 ctor
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;如果一个类中有virtual方法，不论是声明还是继承来的，因为需要虚表，所以必然得有构造函数来初始化vptr的值令其指向虚表，这种情况下，没有任何构造函数的类编译器会合成一个默认构造函数（为了初始化虚表），有构造函数的编译器会进行相应的扩展。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;相应的，如果类在继承链上有一个虚继承的基类，那么编译器很可能需要在类中插入一个指向该基类的指针（或者其它机制，总之需要进行一翻操作），这就要求一个构造函数来操作。所以这种情况下，如果类没有任何构造函数编译器就合成一个完成该操作的合成默认构造函数；若有程序员提供的构造函数，编译器就扩展它们。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;总结：以上四种情况说明的是 ，&lt;strong&gt;&lt;em&gt;对编译器而言，有必要合成默认构造函数&lt;/em&gt;&lt;/strong&gt;的情况。也就是编译器合成默认构造函数或者扩展构造函数的目的与作用：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;调用类成员的默认构造函数&lt;/li&gt;
&lt;li&gt;调用父类的默认构造函数&lt;/li&gt;
&lt;li&gt;为类初始化虚表相关的操作&lt;/li&gt;
&lt;li&gt;为类初始化虚基类机制&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;一旦上面四条对于一个类来说都不需要，那么合成的默认构造函数被就是trivial（没有用）的，而实际上编译器不会将这种构造函数生成出来。
还记得primer中有个聚合类（aggregate class），当聚合类不含类成员时，上面四个状态就都不满足，那编译器就不会给他生成合成默认构造函数了。所以：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;任何class没有定义构造函数，编译器会生成一个合成默认构造函数&lt;/li&gt;
&lt;li&gt;编译器合成的默认构造函数会初始化所有类的成员&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;这两个观点都不正确&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;同样，拷贝构造函数也有trivial和nontrivial之分，编译器只会生成nontrivial的拷贝构造函数。而判断trivial的标准就在于类是否展现出位逐次拷贝（Bitwise Copy Semantics）特性。首先，看下primer是怎么说的：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;与合成默认构造函数不同，即使我们定义了其它构造函数，编译器也会为我们合成一个拷贝构造函数。&lt;/p&gt;

&lt;p&gt;而一般情况，合成的拷贝构造函数会将其参数的成员逐个拷贝到正在创建的对象中。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;下面是inside的分析：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;当一个类的成员中有一个类，该类成员有拷贝构造函数（不论是它显示声明的，还是编译器因为非位逐次拷贝而生成的。第二个说法有点绕口，其实就是说，如果该类成员也有一个有拷贝构造函数的类成员。。。。递归中。。。。）&lt;/li&gt;

&lt;li&gt;&lt;p&gt;当类的继承链上有一个有拷贝构造函数（和上面括号中描述的一样，两种情况），这两种情况下类是无法进行位逐次拷贝的，此时编译器会生成一个默认拷贝构造函数来调用类成员／基类的拷贝构造函数：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;iostream&amp;gt;
using namespace std;
struct bitwise{
    int n;
    char *hehe;
};
struct goodcopy{
    goodcopy(){}
    goodcopy(const goodcopy&amp;amp;){cout&amp;lt;&amp;lt;&amp;quot;good copy!!&amp;quot;&amp;lt;&amp;lt;endl;}
};
struct nonbitwise{
    goodcopy gc;
};
struct nonbitwise2:public goodcopy{

};
struct nonbitwise3{
    nonbitwise3(){}
    nonbitwise3(const nonbitwise3&amp;amp;){}
    goodcopy gc;
};
int main(){
    bitwise bw1;
    char * str=&amp;quot;blabla!&amp;quot;;
    bw1.hehe=str;
    bw1.n=1;
    bitwise bw2(bw1);
    cout&amp;lt;&amp;lt;&amp;quot;bw1 n &amp;quot;&amp;lt;&amp;lt;bw1.n&amp;lt;&amp;lt;&amp;quot; hehe &amp;quot;&amp;lt;&amp;lt;bw1.hehe&amp;lt;&amp;lt;endl;
    cout&amp;lt;&amp;lt;&amp;quot;bw2 n &amp;quot;&amp;lt;&amp;lt;bw2.n&amp;lt;&amp;lt;&amp;quot; hehe &amp;quot;&amp;lt;&amp;lt;bw2.hehe&amp;lt;&amp;lt;endl;
    cout&amp;lt;&amp;lt;&amp;quot;=============================&amp;quot;&amp;lt;&amp;lt;endl;
    nonbitwise nbw1;
    nonbitwise nbw12(nbw1);
    cout&amp;lt;&amp;lt;&amp;quot;=============================&amp;quot;&amp;lt;&amp;lt;endl;
    nonbitwise2 nbw2;
    nonbitwise2 nbw22(nbw2);
    cout&amp;lt;&amp;lt;&amp;quot;=============================&amp;quot;&amp;lt;&amp;lt;endl;
    nonbitwise3 nbw3;
    nonbitwise3 nbw32(nbw3);
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ ./bitwisecopy.out
bw1 n 1 hehe blabla!
bw2 n 1 hehe blabla!
=============================
good copy!!
=============================
good copy!!
=============================

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面的代码中，不能进行位逐次拷贝的nonbitwise2和nonbitwise都由编译器生成了nontrivial的拷贝构造函数来调用goodcopy的拷贝构造函数；而nonbitwise3虽然也不能位逐次拷贝，但是由于程序员定义了拷贝构造函数，所以编译器没有为其生成，而且也没有对其进行扩展，这一点与默认构造函数不同
1.
如果一个类中含有虚函数，那这个类中必然会有虚表。这样的话，如果这个类之间进行拷贝（子类到子类，类型相同），使用位逐次拷贝是可以的，因为两个类类型相同，虚表指针指向相同的虚表。但是考虑这种情况，当一个子类拷贝给一个父类时，仍然使用位逐次拷贝，可以么？这种情况下的拷贝会发生子类的截断，即只拷贝其基类部分。而位逐次拷贝会使基类的虚表指针指向子类的虚表，而其子类部分又不存在（因为这货是基类啊）所以不能用位逐次拷贝，需要对虚表指针进行处理。综合一下就是，类中含有虚函数，就不能位逐次拷贝。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;同样的，如果一个类的继承链上存在虚继承关系，也不能单纯的用位逐次拷贝处理子类拷贝给父类的情况，而需要编译器合成一个拷贝构造函数。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;对于拷贝构造在函数传参和返回中的使用，主要注意NRV。先来看一个函数是如何返回一个类的：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;struct someone{
    someone(const someone &amp;amp;x){/*...*/}
//...
}
someone func(int n){
    someone t;
    //...
    return t;
}
someone r=func(1);
//实际中编译器很可能会产生如下代码
void func(int n, someone&amp;amp; ret){
    someone t;
    //...
    ret.someone::someone(t);
}
someone r; //此处不执行someone的默认构造函数
func(1,r);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里就可以发现返回类的函数被处理为通过参数来返回的函数了。这时，完全可以省去临时类t：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;void func(int n, someone&amp;amp; ret){
    ret.someone::someone();
    //...
    return;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这就是NRV优化（Named Return Value），也就是对函数中的中间类直接用返回值的引用替换，省去一个临时类，就省去了一次默认构造和拷贝构造以及一次析构的开销。但是NRV也有缺点：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;不同的编译器，其NRV的实现程度不一样，也就是编译器不一定会实现NRV&lt;/li&gt;
&lt;li&gt;不同复杂度的函数，NRV实现程度也不一样&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;这些不确定性让我们不敢依靠NRV来评估软件性能（所以c++11的右值引用是一大亮点）。另外，关于到底要不要明确的写出拷贝构造函数，总结一下就是，如果类可以位逐次拷贝，那就不要写，因为编译器会生成一个trivial的拷贝构造函数，效率很高，自己写的话很有可能使效率下降。至于书中说的explicit copy constructor与NRV的关系，我查了下，见这篇&lt;a href=&#34;http://www.cnblogs.com/cyttina/archive/2012/11/26/2790076.html&#34;&gt;文章&lt;/a&gt;，就是说，嗯，没关系。。。。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;最后，关于构造函数初始化列表：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;注意初始化顺序，按成员声明的顺序来。尽量不要交织。&lt;/li&gt;
&lt;li&gt;尤其不要用在子类的初始化列表中用子类的成员函数为父类的构造函数提供参数，比如：&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;struct father{
    //...
    father(int n){/*...*/}
    //...
};
struct son:public father{
    //...
    son(int x):_t(x),father(memberfunc(x)){/*...*/}
    //...
    int memberfunc(int n){/*...*/}
    int _t;
};
//...  编译器有可能把初始化列表转化为
// son::son(/*...this pointer...*/){
    // father::father(this,this-&amp;gt;memberfunc(x)); //尼玛，this的son部分还没构建你就以及调用它的方法了！！！！！
    // _t=x;
// }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最后注意，在构造活着析构函数中调用虚函数，虚函数一定是当前构造／析构函数所属类型的虚函数，因为再往下，子类部分要不还没构建，要不就已经析构了。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;

&lt;p&gt;对于构造函数，一句总结就是，如果写了任何构造函数，编译器就不会给你生成默认构造函数了。对于拷贝构造，不需要明确写的就不要写，对于初始化列表，不要“交织”！&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>cpp primer 第十五章笔记</title>
      <link>http://shamaoxiaogui.github.io/post/cpp_primer_note_15/</link>
      <pubDate>Thu, 21 Jul 2016 10:57:42 +0800</pubDate>
      
      <guid>http://shamaoxiaogui.github.io/post/cpp_primer_note_15/</guid>
      <description>&lt;p&gt;终于到了第十五章了，复习大计实施的还不错～～&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;动态绑定可以用指针或者引用实现&lt;/li&gt;
&lt;li&gt;基类的析构函数一般都应该是virtual修饰的，因为通常我们会在一个基类指针中存放一个派生类的指针，delete这个指针时编译器要调用合适的析构函数，讲基类的析构函数定义为virtual的使编译器自动调用派生类的析构函数。不用担心，析构时仍然会调用基类的析构函数&lt;/li&gt;
&lt;li&gt;在用于覆盖虚函数的函数后面可以添加关键字override来显示注明，位置是const和引用限定符后面&lt;/li&gt;
&lt;li&gt;静态成员可以被继承切在整个继承体系中只有一个&lt;/li&gt;
&lt;li&gt;防止继承，在类定义后面加final关键字&lt;/li&gt;
&lt;li&gt;基类的拷贝构造函数不是虚函数，因为用一个派生类给基类赋值只会赋值派生类中的基类部分&lt;/li&gt;
&lt;li&gt;类中普通的成员函数我们可以只提供声明而不定义，只要不使用即可，但是必须为所有的虚函数提供定义，因为直到运行时才会知道哪个虚函数被使用了&lt;/li&gt;
&lt;li&gt;引用和指针的静态类型与动态类型不同这一事实正是C++语言支持多态的根本所在&lt;/li&gt;
&lt;li&gt;如果派生类中覆盖了某个虚函数，它可以再一次使用virtual指定其虚函数属性，然而这是&lt;strong&gt;&lt;em&gt;没必要的&lt;/em&gt;&lt;/strong&gt;，因为一旦某个函数被声明为虚函数，在整个继承体系中它都是虚函数。&lt;/li&gt;
&lt;li&gt;派生类要覆盖虚函数，新函数必须有与虚函数一样的参数和返回值，唯一的&lt;strong&gt;&lt;em&gt;例外&lt;/em&gt;&lt;/strong&gt;是，如果虚函数返回的是类本身（基类）的指针或引用，那么覆盖函数允许返回派生类的指针或引用&lt;/li&gt;
&lt;li&gt;也可以将某个函数指定为final，防止后续派生类覆盖它（一般用于间接派生中，自己定义了一个覆盖父类的虚函数，但是不希望后续子类覆盖它）&lt;/li&gt;
&lt;li&gt;虚函数中使用默认实参是依赖与当前的&lt;strong&gt;&lt;em&gt;静态类型&lt;/em&gt;&lt;/strong&gt;的！！！所以最好将一个虚函数所有的覆盖函数中的默认实参定义成一样的，防止出错&lt;/li&gt;
&lt;li&gt;使用作用域运算符可以回避虚函数机制，静态指定调用目标，这一般用在派生类的虚函数需要调用基类的虚函数做一些操作的时候，此时如果不指定作用域，运行时会被解析为调用自身，从而无限递归&lt;/li&gt;
&lt;li&gt;纯虚函数，带 =0 的虚函数，可以不提供定义（一般不提供），也可以提供，但是必须在类外定义。&lt;/li&gt;
&lt;li&gt;含有（或者直接继承，没有覆盖）纯虚函数的类是抽象基类，抽象基类不能创建对象&lt;/li&gt;
&lt;li&gt;protected成员：

&lt;ol&gt;
&lt;li&gt;用户不可访问，但是对其派生类和其友元是可以访问的（注意是基类的友元）&lt;/li&gt;
&lt;li&gt;对于派生类的友元，想要访问基类的protected成员，只能通过派生类来“代理”访问&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;关于派生类向基类转换的可访问性，引用primer的总结，&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;对于代码中的某个给定节点来说，如果基类的公有成员是可访问的，则派生类向基类的类型转换也是可访问的；反之则不行。&lt;/p&gt;
&lt;/blockquote&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;友元没有传递性，友元也不能继承&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;可以用using声明改变继承来的可访问成员的可访问性（比如把private继承来的某父类成员用using声明变成public的）&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;struct默认访问说明符为public，默认继承保护级别也是public；而class默认访问说明符是private的，默认继承保护级别也是private（but还是显示声明吧。。。）&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;指针和引用的静态类型决定哪些成员可见&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;名字查找先于类型检查，所以派生类中的函数会隐藏掉基类中的同名函数，即使二者函数签名不同，也不会构成函数重载&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;所以说，如果在覆盖虚函数的时候写错了参数，不但不能覆盖虚函数（用基类指针调用虚函数调用的是基类的虚函数），而且还会在派生类中隐藏掉该虚函数（用该派生类指针调用虚函数会报错，因为虚函数被隐藏了），比如：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;iostream&amp;gt;
class base{
public:
    virtual int func(){std::cout&amp;lt;&amp;lt;&amp;quot;base v&amp;quot;&amp;lt;&amp;lt;std::endl;}
};
class d1:public base{
public:
    int func(int n){std::cout&amp;lt;&amp;lt;&amp;quot;d1 func&amp;quot;&amp;lt;&amp;lt;std::endl;}
};
int main(){
    base *bp=new d1;
    d1 *dp=bp;
    bp-&amp;gt;func();     //调用的是base的虚函数func
    //dp-&amp;gt;dunc();     //编译错误，因为对d1而言，base的虚函数func被d1的func(int)隐藏了
    delete bp;
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;起始对于派生类来说，基类的虚函数和非虚函数都可以覆盖，只不过覆盖虚函数可以在其基类指针中动态调用，而非虚函数不行。但是，一旦定义一个名字与基类中某个函数一样的函数，基类中的函数就被覆盖了，基类中的所有的该函数的重载函数也一样。所以如果想在派生类中使用基类的所有重载函数，要不就不要覆盖，要不就把每个重载函数都覆盖。或者，用一条using声明将基类中的函数“拿”到派生类的public域中，然后再覆盖其中要覆盖的函数。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;iostream&amp;gt;
class base{
public:
    void func(){std::cout&amp;lt;&amp;lt;&amp;quot;bfunc&amp;quot;&amp;lt;&amp;lt;std::endl;}
    void func(int n){std::cout&amp;lt;&amp;lt;&amp;quot;bfunc2&amp;quot;&amp;lt;&amp;lt;std::endl;}
    int x=0;
};
class d1:public base{
public:
    using base::func;
    void func(){std::cout&amp;lt;&amp;lt;&amp;quot;dfunc&amp;quot;&amp;lt;&amp;lt;std::endl;}
    using base::x;
    int x=1;
};
int main(){
    d1 d;
    d.func();
    d.func(3);
//    std::cout&amp;lt;&amp;lt;&amp;quot;d.x=&amp;quot;&amp;lt;&amp;lt;d.x&amp;lt;&amp;lt;std::endl;    //二义性错误
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;派生类的构造函数、拷贝构造函数、拷贝赋值运算符以及移动构造函数、移动赋值运算符都应该显式调用基类的相关函数，传入复制／移动对象即可，因为基类的这些函数参数一定是个引用，基类可以引用派生类。而析构函数则不需要，只释放自己的资源就好。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;如果在构造或析构函数中调用了虚函数，调用的是当前函数对应类的虚函数版本，不会调用派生类的版本，因为此时派生类部分还没有初始化活着已经析构了，不存在（换句话说，此时虚表中不存在派生类的信息）。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;iostream&amp;gt;
using namespace std;
class base{
public:
    base(){vfunc();}
    virtual void vfunc(){cout&amp;lt;&amp;lt;&amp;quot;base n: &amp;quot;&amp;lt;&amp;lt;n&amp;lt;&amp;lt;endl;}
    virtual ~base(){cout&amp;lt;&amp;lt;&amp;quot;d base &amp;quot;;vfunc();}
private:
    int n=0;
};
class d1:public base{
public:
    d1(){vfunc();}
    void vfunc(){cout&amp;lt;&amp;lt;&amp;quot;d1 x: &amp;quot;&amp;lt;&amp;lt;x&amp;lt;&amp;lt;endl;}
    ~d1(){cout&amp;lt;&amp;lt;&amp;quot;d d1&amp;quot;;vfunc();}
private:
    int x=1;
};
int main(){
    // d1 d;
    base *bp=new d1;
    delete bp;
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ ./dcvirtual.out
base n: 0
d1 x: 1
d d1d1 x: 1
d base base n: 0
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;因为向一个基类赋值派生类会产生“截断”现象（因为调用的是基类的拷贝函数），所以不要在容器中直接存储基类对象，这样一旦你向其中放入派生类，就会截断，切编译器不会报错。应在容器中存储基类指针。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>cpp primer 第十四章笔记</title>
      <link>http://shamaoxiaogui.github.io/post/cpp_primer_note_14/</link>
      <pubDate>Thu, 21 Jul 2016 09:18:59 +0800</pubDate>
      
      <guid>http://shamaoxiaogui.github.io/post/cpp_primer_note_14/</guid>
      <description>&lt;p&gt;第十四章主要讲运算符重载和类型转换（感觉每次第一句话都是废话）：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;不应该被重载的运算符：&lt;code&gt;&amp;amp;&amp;amp; || ,&lt;/code&gt;因为无法保留其运算顺序（还有逻辑运算符的短路运算属性），而对于逗号和取址运算，语言已经定义了其对于类的特殊含义&lt;/li&gt;
&lt;li&gt;必须定义为成员函数的运算符：&lt;code&gt;= [] () -&amp;gt;&lt;/code&gt;（语言也禁止这样做）&lt;/li&gt;
&lt;li&gt;对于需要对称性的运算符（＋），可能会转换任一端参数，定义为普通函数&lt;/li&gt;
&lt;li&gt;对于输入输出运算符的重载，注意：

&lt;ol&gt;
&lt;li&gt;减少格式化输出，不应该添加换行符&lt;/li&gt;
&lt;li&gt;输入输出运算符必须是非成员函数&lt;/li&gt;
&lt;li&gt;输入运算符中应处理出错情况，负责从错误中恢复；输出运算符则不需要考虑错误&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;同时定义了算术运算符和相关的复合赋值运算，应优先使用复合赋值（开销小）&lt;/li&gt;

&lt;li&gt;&lt;p&gt;递增递减运算的原型：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class X{
public:
    X&amp;amp; operator++();    //前置
    X operator++(int);  //后置，其中参数不会用到
};
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;下表运算一般定义两个版本，普通的返回引用，加const限定符的返回常量引用&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;lambda表达式产生的类不含默认构造函数、赋值运算符、默认析构函数&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;cpp的可调用对象有：函数、函数指针、lambda表达式、bind对象、函数对象&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;std::function模版可以用来存放或者说是接受可调用对象，但是不能放重载函数，解决方案是使用函数指针活着lambda给重载函数做一个“别名”。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;类型转换函数，可以定义为转换成任何能作为函数返回类型的类型（数组、函数类型就不行，但是数组指针和函数指针可以）；必须是类的成员函数；无返回类型参数列表；通常const限定：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;operator type() const;
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;显示的类型转换运算符，就是在前面加explicit，使用时必须用cast。例外：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;if，while，do语句条件部分&lt;/li&gt;
&lt;li&gt;for语句条件部分&lt;/li&gt;
&lt;li&gt;&lt;code&gt;! || &amp;amp;&amp;amp;&lt;/code&gt;运算对象&lt;/li&gt;
&lt;li&gt;条件运算符表达式（?:）的条件部分&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;这些语句中会隐式的调用显示类型转换运算符中转换为bool的那类。比如io库中，我们经常用：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;while(cin&amp;gt;&amp;gt;n){
...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;所以，一般向bool型的类型转换我们可以大胆的写成explicit的（一般也只定义向bool的转换）&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>cpp primer 第十三章笔记</title>
      <link>http://shamaoxiaogui.github.io/post/cpp_primer_note_13/</link>
      <pubDate>Wed, 20 Jul 2016 21:40:45 +0800</pubDate>
      
      <guid>http://shamaoxiaogui.github.io/post/cpp_primer_note_13/</guid>
      <description>&lt;p&gt;嘿嘿，飙到第十三章了～～老司机的笑容像天上的弦月～～毕竟是补漏。。。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;拷贝构造函数通常不应该是explicit的，参数必须为引用类型（常量引用）&lt;/li&gt;
&lt;li&gt;合成的拷贝构造函数对于数组成员会逐一拷贝其元素&lt;/li&gt;
&lt;li&gt;编译器有时会绕过拷贝构造函数（优化为直接构造）&lt;/li&gt;
&lt;li&gt;三／五法则：析构函数，拷贝构造函数，拷贝赋值运算符，移动构造函数，移动赋值运算符，可以看成一个整体，通常需要定义其中一个也就意味着需要定义其余四个。&lt;/li&gt;
&lt;li&gt;新司机还记得&lt;code&gt;=default&lt;/code&gt;不？&lt;/li&gt;
&lt;li&gt;阻止拷贝：旧标准可以把相关构造函数&lt;strong&gt;&lt;em&gt;声明&lt;/em&gt;&lt;/strong&gt;为private，不需要定义；新标准可以用&lt;code&gt;=delete&lt;/code&gt;。当不能拷贝、赋值或销毁类的成员时，类的合成拷贝控制成员就被定义为删除的&lt;/li&gt;
&lt;li&gt;对于一个赋值运算符，编写时需要考虑：

&lt;ol&gt;
&lt;li&gt;一个对象赋值给它自身，要工作正常（所以要在析构当前对象前保存“新”对象）&lt;/li&gt;
&lt;li&gt;拷贝＋析构&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;如果swap操作不会拷贝对象而只是交换指针（通常都是如此），那么可以利用“拷贝并交换”技术来编写赋值运算：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;tc&amp;amp; operator=(tc rhs){  //传值复制了rhs
    swap(*this,rhs);    
    return *this;
}   //rhs也就是原来的本对象会自动析构
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;左值引用不能绑定到&lt;strong&gt;&lt;em&gt;要求转换的表达式、字面常量、返回右值的表达式&lt;/em&gt;&lt;/strong&gt;，但是常量左值引用可以哦，而右值引用则和左值引用完成相反&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;int i=10;
double &amp;amp;rd=i;   //error
int &amp;amp;ri=30;     //error
int &amp;amp;rri=i+3;   //error
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;右值短暂，都是临时对象，左值持久。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;右值和右值引用是不一样的，简单的说，右值就是临时量，不是变量，而右值引用是引用右值的变量，是个变量，它通过引用右值（临时量）将临时量变为变量，本来临时量马上就会消亡，你一用右值引用引用它，就把它变成一个持久的变量了，所以primer说，右值引用从绑定到其的临时量中“窃取”状态。同样的，右值引用是一个变量不是临时量，所以右值引用不能绑定右值引用（绕口。。。），还有，右值意味着它只有你这个所有者，你可以为所欲为（修改它）&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;使用&lt;code&gt;std::move&lt;/code&gt;可以将一个左值转换为右值引用，也就是告诉编译器，这个左值劳资要当成右值用，你放心，过会儿劳资就削了它！（也就是说除了销魂不能对它再做任何操作，起始还可以再赋值给他，但是不能直接使用它的值。。。）
1.
移动构造函数和移动赋值运算符，参数都是非const的右值引用，调用后移后对象应处于可析构状态（意思是说，假设把a移动给b，就算你在调用移动构造函数之后把a析构了，也不会影响到b的内容，主要是考虑指针的处理），再者二者不应该抛出异常，使用noexcept关键字（编译器看到这个关键字的话，在这个函数抛出异常时，会直接调用terminate()，同时，它也告诉标准库容器该类的移动构造函数不会抛出异常，否则，标准库会因为预防发生异常的时候需要恢复原状而使用拷贝语义）。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;拷贝左值，移动右值，没有移动就只能拷贝右值&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;标准库的重载函数往往有两个版本：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;void push_back(const X&amp;amp;);   //copy
void push_back(X&amp;amp;&amp;amp;);    //move
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;拷贝操作对参数应该没有影响，故而必然是const的，而移动操作会对移后对象进行操作，所以必然是非const的&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;可以在成员函数后面活着重载运算符后面加引用限定符表示this指向的对象只能是左值或者右值&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class foo{
public:
    foo&amp;amp; operator=(const foo&amp;amp;) &amp;amp;;   //只有左值才能使用＝
    void somefunc() &amp;amp;&amp;amp;;     //只有右值才能使用该函数
    void hehe() const &amp;amp;;    //只有const左值才能使用该函数，const必须在前
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;至于重载函数，const限定符的成员函数和同名同参的普通成员函数构成重载，而不同引用限定符的同名同参成员函数之间也构成重载，重载的对象就是类本身是左值还是右值。另外，一旦在const限定符与普通重载函数之间的任何一个上用了引用限定符，那这一组重载函数中就都得用引用限定符了；&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>cpp primer 第七章笔记</title>
      <link>http://shamaoxiaogui.github.io/post/cpp_primer_note_7/</link>
      <pubDate>Wed, 20 Jul 2016 16:36:02 +0800</pubDate>
      
      <guid>http://shamaoxiaogui.github.io/post/cpp_primer_note_7/</guid>
      <description>&lt;p&gt;第七章，终于到正题了，类：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;只有在类中没有任何构造函数时，编译器才会生产合成默认构造函数；只有当类内部的内置类型被赋予类内初始值时，合成默认构造函数才有可能合适；如果类内包含其它的没有默认构造函数的类时，编译器不能为其生成合成默认构造函数；可以明确指定使用合成默认构造函数：&lt;code&gt;xxx()=default;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;继承的三种方式，参见&lt;a href=&#34;http://blog.csdn.net/complety/article/details/7493194&#34;&gt;文章&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;友元也会被继承，但是友元类不具有传递性；友元声明仅仅是友元声明，一般需要在类定义外加一个普通函数声明（一般类定义是放在头文件的，所以一般也需要这个普通函数声明），虽然有的编译器不这么要求&lt;/li&gt;
&lt;li&gt;mutable关键字是说，即使类的实体是个const实体，其mutable成员也是可以改变的&lt;/li&gt;
&lt;li&gt;类内初始值可以用＝和花括号&lt;/li&gt;
&lt;li&gt;对于类中的const、引用或者未提供默认构造函数的类成员，必须用类内初始值或者构造函数的初始值列表来初始化，而不能直接在构造函数中“初始化”（原因很简单，构造函数中的“初始化”实际上是先对成员进行默认初始化，然后赋值，上面这三种都不能默认初始化）&lt;/li&gt;

&lt;li&gt;&lt;p&gt;关于构造顺序，我们可以做个实验：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;string&amp;gt;
using std::string;
using std::cout;
using std::endl;
class member{
public:
    member(int n):m(n){cout&amp;lt;&amp;lt;&amp;quot;member &amp;quot;&amp;lt;&amp;lt;m&amp;lt;&amp;lt;&amp;quot; ctor&amp;quot;&amp;lt;&amp;lt;endl;}
    ~member(){cout&amp;lt;&amp;lt;&amp;quot;member &amp;quot;&amp;lt;&amp;lt;m&amp;lt;&amp;lt;&amp;quot; dctor&amp;quot;&amp;lt;&amp;lt;endl;}
private:
    int m; 
};
class grandpa{
public:
    grandpa(const string&amp;amp; n=&amp;quot;G&amp;quot;):name(n){cout&amp;lt;&amp;lt;&amp;quot;grand &amp;quot;&amp;lt;&amp;lt;name&amp;lt;&amp;lt;&amp;quot; ctor&amp;quot;&amp;lt;&amp;lt;endl;}
    ~grandpa(){cout&amp;lt;&amp;lt;&amp;quot;grand &amp;quot;&amp;lt;&amp;lt;name&amp;lt;&amp;lt;&amp;quot; dctor&amp;quot;&amp;lt;&amp;lt;endl;}
private:
    string name;
};
class father:public grandpa{
public:
    father(const string&amp;amp; n=&amp;quot;F&amp;quot;):name(n){cout&amp;lt;&amp;lt;&amp;quot;father &amp;quot;&amp;lt;&amp;lt;name&amp;lt;&amp;lt;&amp;quot; ctor&amp;quot;&amp;lt;&amp;lt;endl;}
    ~father(){cout&amp;lt;&amp;lt;&amp;quot;father &amp;quot;&amp;lt;&amp;lt;name&amp;lt;&amp;lt;&amp;quot; dctor&amp;quot;&amp;lt;&amp;lt;endl;}
private:
    string name;
};
class child:public father{
public:
    child(const string&amp;amp; n=&amp;quot;C&amp;quot;):m1(1),m2(2),m3(3),name(n){cout&amp;lt;&amp;lt;&amp;quot;child &amp;quot;&amp;lt;&amp;lt;name&amp;lt;&amp;lt;&amp;quot; ctor&amp;quot;&amp;lt;&amp;lt;endl;}
    ~child(){cout&amp;lt;&amp;lt;&amp;quot;child &amp;quot;&amp;lt;&amp;lt;name&amp;lt;&amp;lt;&amp;quot; dctor&amp;quot;&amp;lt;&amp;lt;endl;}
private:
    string name;
    static member m4;
    member m1,m2,m3;
};
member child::m4(4);
int main(){
    child ch;
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ ./initorder.out
member 4 ctor
grand G ctor
father F ctor
member 1 ctor
member 2 ctor
member 3 ctor
child C ctor
child C dctor
member 3 dctor
member 2 dctor
member 1 dctor
father F dctor
grand G dctor
member 4 dctor
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;总结一下：首先，类的静态变量和程序的全局变量一起初始化，然后类的父类初始化，然后类自身初始化，其中成员按照定义的顺序初始化，最后执行类自身的构造函数。析构的时候，完全反过来：先调用自己的析构，然后逆着成员的定义顺序析构成员，最后调用父类的析构函数。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;委托构造函数，嗯，好东西，有了这个就不需要之前的init辅助函数&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;explicit禁止隐式转换，切不能当成拷贝初始化，但可以用构造函数显示转换为临时对象，或者static_cast也可以&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;聚合类的条件：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;所有成员public&lt;/li&gt;
&lt;li&gt;没定义任何构造函数&lt;/li&gt;
&lt;li&gt;没有类内初始值&lt;/li&gt;
&lt;li&gt;没有基类，没有虚函数&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>cpp primer 第六章笔记</title>
      <link>http://shamaoxiaogui.github.io/post/cpp_primer_note_6/</link>
      <pubDate>Wed, 20 Jul 2016 14:49:08 +0800</pubDate>
      
      <guid>http://shamaoxiaogui.github.io/post/cpp_primer_note_6/</guid>
      <description>&lt;p&gt;第六章主要是函数相关的内容：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;函数是可以没有定义只有声明的，只要你不用它（变量声明，类的前置声明也是）。。。&lt;/li&gt;
&lt;li&gt;关于引用与指针，我觉得最重要的区别的话，主要是

&lt;ol&gt;
&lt;li&gt;引用初始化后就不能再改变引用的对象了，而指针可以指向不同的对象&lt;/li&gt;
&lt;li&gt;有空指针没有空引用&lt;/li&gt;
&lt;li&gt;引用是对象的别名，不是一个对象，而指针是一个专门用来存放地址的对象，所以sizeof二者会有区别&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;对于函数的参数，可以理解为c++只有传值，没有传引用，其传引用是通过对地址的传值实现的。数组传引用时会退化成指针，当使用引用来作为数组形参时，需要指定维度，不符合维度的数组不能匹配到该函数&lt;/li&gt;
&lt;li&gt;又到了可爱的initializer_list，记住注意复制开销&lt;/li&gt;
&lt;li&gt;关于函数return临时对象的问题，参见&lt;a href=&#34;http://www.cnblogs.com/xkfz007/articles/2506022.html&#34;&gt;文章&lt;/a&gt;，可见编译器帮我们做了很多事情，但是仍然注意后面的右值引用和完美转发&lt;/li&gt;
&lt;li&gt;inline和constexpr函数可以定义多次，但是定义必须完全一样，所以一般把它们放到头文件中&lt;/li&gt;

&lt;li&gt;&lt;p&gt;对于函数对象和函数的比较，发现效率似乎差距不大（clang）&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;chrono&amp;gt;
auto func1(int t)-&amp;gt;int{
    return ++t;
}
class func2{
public:
    auto operator()(int t)-&amp;gt;int{
        return ++t;
    }
};
inline int func3(int t){
    return ++t;
}
static inline int func4(int t){
    return ++t;
}
int main(){
    int n,i=0;
    std::chrono::high_resolution_clock::time_point t1,t2;
    std::cout&amp;lt;&amp;lt;&amp;quot;input: &amp;quot;;
    std::cin&amp;gt;&amp;gt;n;
    std::cout&amp;lt;&amp;lt;std::endl;
    std::cout&amp;lt;&amp;lt;&amp;quot;=========================&amp;quot;&amp;lt;&amp;lt;std::endl;
    t1=std::chrono::high_resolution_clock::now();
    for(int j=0;j&amp;lt;n;++j){
        i=func1(j);
    }
    t2=std::chrono::high_resolution_clock::now();
    std::cout&amp;lt;&amp;lt;&amp;quot;time: &amp;quot;&amp;lt;&amp;lt;std::chrono::duration_cast&amp;lt;std::chrono::microseconds&amp;gt;(t2-t1).count()&amp;lt;&amp;lt;&amp;quot; microseconds&amp;quot;&amp;lt;&amp;lt;std::endl;
    std::cout&amp;lt;&amp;lt;&amp;quot;=========================&amp;quot;&amp;lt;&amp;lt;std::endl;
    func2 func2i;
    t1=std::chrono::high_resolution_clock::now();
    for(int j=0;j&amp;lt;n;++j){
        i=func2i(j);
    }
    t2=std::chrono::high_resolution_clock::now();
    std::cout&amp;lt;&amp;lt;&amp;quot;time: &amp;quot;&amp;lt;&amp;lt;std::chrono::duration_cast&amp;lt;std::chrono::microseconds&amp;gt;(t2-t1).count()&amp;lt;&amp;lt;&amp;quot; microseconds&amp;quot;&amp;lt;&amp;lt;std::endl;
    std::cout&amp;lt;&amp;lt;&amp;quot;=========================&amp;quot;&amp;lt;&amp;lt;std::endl;
    t1=std::chrono::high_resolution_clock::now();
    for(int j=0;j&amp;lt;n;++j){
        i=func3(j);
    }
    t2=std::chrono::high_resolution_clock::now();
    std::cout&amp;lt;&amp;lt;&amp;quot;time: &amp;quot;&amp;lt;&amp;lt;std::chrono::duration_cast&amp;lt;std::chrono::microseconds&amp;gt;(t2-t1).count()&amp;lt;&amp;lt;&amp;quot; microseconds&amp;quot;&amp;lt;&amp;lt;std::endl;
    std::cout&amp;lt;&amp;lt;&amp;quot;=========================&amp;quot;&amp;lt;&amp;lt;std::endl;
    t1=std::chrono::high_resolution_clock::now();
    for(int j=0;j&amp;lt;n;++j){
        i=func4(j);
    }
    t2=std::chrono::high_resolution_clock::now();
    std::cout&amp;lt;&amp;lt;&amp;quot;time: &amp;quot;&amp;lt;&amp;lt;std::chrono::duration_cast&amp;lt;std::chrono::microseconds&amp;gt;(t2-t1).count()&amp;lt;&amp;lt;&amp;quot; microseconds&amp;quot;&amp;lt;&amp;lt;std::endl;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ ./functest.out
input: 1000000000

=========================
time: 3859925 microseconds
=========================
time: 3849522 microseconds
=========================
time: 3647694 microseconds
=========================
time: 3865106 microseconds
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>cpp primer 第五章笔记</title>
      <link>http://shamaoxiaogui.github.io/post/cpp_primer_note_5/</link>
      <pubDate>Wed, 20 Jul 2016 13:59:57 +0800</pubDate>
      
      <guid>http://shamaoxiaogui.github.io/post/cpp_primer_note_5/</guid>
      <description>&lt;p&gt;第五章讲解语句：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;注意switch内部块中定义的变量，尽管在同一个作用域中（case后面不跟大括号的情况），但是只要是没有初始化的变量就不能使用，比如&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;switch(ch){
case &#39;a&#39;:
    string name;    //错误，可能绕开隐式初始化
    int a=0;    //错误，可能绕开显示初始化
    int b;  //正确，未初始化，可以在其他控制块中初始化
    break;
case &#39;b&#39;:
    b=1;    //正确，赋值
    if(name.empty())    //错误，虽然在作用域内，但没有初始化
    //...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;简单有效的做法是，限定作用域，即在case后使用大括号&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;关于异常，这里引用陈硕在知乎上的回答：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;作者：陈硕
链接：&lt;a href=&#34;http://www.zhihu.com/question/22889420/answer/22975569&#34;&gt;http://www.zhihu.com/question/22889420/answer/22975569&lt;/a&gt;
来源：知乎
著作权归作者所有，转载请联系作者获得授权。&lt;/p&gt;

&lt;p&gt;整个 C++ exception 的行为在常见语言中是最奇葩的， 因为这个语言特性与 C++ 其他 feature（特别是确定性析构） 格格不入。在 C++ 中全面铺开使用异常会遇到其他语言中不存在的问题。&lt;/p&gt;

&lt;p&gt;从网上容易找到一些公司/组织的C++编码规范，其中至少 Google、Mozilla、Qt、LLVM 这几家的规范是明确禁用异常的。前面三家或许可以用代码历史包袱、程序员C++水平参差不齐、保证可移植性等理由来解释，但是 LLVM 却不同。首先，LLVM 在 2003 年才发布第一版，是个21世纪的新项目，没什么历史包袱；更重要的是，LLVM 的作者同时也开发了 clang 这个 C++ 编译器，用 C++ 写 C++ 编译器的程序员恐怕是 C++ 程序员里对语言掌握得最好的那一批，如果他们都在项目中明确地禁用异常，这意味着什么呢？注意到 clang 源码已经用上了 C++11，那么“考虑移植性照顾老host编译器”这条理由似乎也不成立了。&lt;/p&gt;

&lt;p&gt;C++ 引入异常的原因之一是为了能让构造函数报错（析构函数不能抛异常这是大家都知道的常识），毕竟构造函数没有返回值，没有异常的话调用方如何得知对象构造是否成功呢？但是编译器/标准库为了让构造函数能抛异常却是麻烦重重：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;数组元素构造时抛异常，前面已经构造好的元素要析构，还没有构造的元素不能析构。&lt;/li&gt;
&lt;li&gt;构造函数的初始化列表里抛异常，前面已经构造好的成员和基类子对象要析构，还没有构造的成员则不能析构。而且这个异常捕获之后必须重新抛出（编译器强制），因为C++不允许“半吊子”构造的对象存在。&lt;/li&gt;
&lt;li&gt;多继承中某个基类的构造函数抛异常，那么已经构造好的基类子对象要析构，还没有构造的基类子对象则不能析构。虚拟继承，虚基类只能析构一次，你慢慢想吧。&lt;/li&gt;
&lt;li&gt;函数实参对象构造时抛异常，那么多个实参中已经构造好的实参对象要析构，尚未构造的实参对象不能析构。&lt;/li&gt;
&lt;li&gt;std::vector 在 resizing 的时候某个元素的拷贝发生异常，那么前面已经拷贝的元素要析构，尚未拷贝的元素则不必也不能析构，去看 gcc vector::_M_insert_aux 的代码有多麻烦。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;（注脚：C++ 引入异常的另一个原因是让 dynamic_cast&lt;Derived&amp;&gt;(baseReference) 能报错，因为没有 null reference。还有一个原因是让 overloaded operator 能报错，毕竟 operator 的返回类型往往无法包含 error code，例如 operator=() 返回的是 Type&amp;amp;。C++ 也是唯一一个变量赋值有可能会抛异常的语言，例如 Person s; s = getPersonById(someId);，那么即便 getPersonById() 不抛异常也不能保证上一句赋值不抛异常。）&lt;/p&gt;

&lt;p&gt;（注脚2：C++ 引入异常的政治原因是 Ada 支持异常，而 Ada 是 DoD 的指定官方语言，如果 C++ 不支持异常，那么 AT&amp;amp;T 贝尔实验室就不能拿 C++ 做 DoD 的项目。）&lt;/p&gt;

&lt;p&gt;C++ 编译器要随时提防调用某个函数 foo 会抛异常，这会阻止一些优化，也会产生很多累赘的代码（随时准备析构那些调用 foo 函数前已经构造好的栈上对象）。因此 C++11 的 noexcept 应该大力推广。&lt;/p&gt;

&lt;p&gt;C++ 的 exception specification 也很鸡肋，它不像 Java 那样在编译期检查（Java 似乎也流行使用 unchecked exception 了），而是在运行期检查，而且违反的后果是直接终止程序，那谁敢用啊？还不如用代码注释呢。有的编译器干脆就只支持语法而不实现功能（Exception Specifications）。C# 也不支持 exception specification，可见这是一项无用的语言特性，算是编程语言发展历史上走的弯路吧，可惜 Java/C++ 掉坑里了。&lt;/p&gt;

&lt;p&gt;其他支持异常的语言几乎都有 GC，抛异常就抛了，不用担心析构，反正GC管着。只有 C++ 才有 exception safety 需要考虑，其他支持异常的语言都没有这一概念。&lt;/p&gt;

&lt;p&gt;而且 Java 的 try-with-resource，C# 的 using，Python 的 with 在管理 function local scope 对象的生命期（资源、lock 释放）方面不比 RAII 麻烦。Go defer 要差一些，它是 function 级，不是 block 级，只能对付 return。 不过反正 Go 也没异常，有点小坑罢了，把函数写短点就能绕过。&lt;/p&gt;

&lt;p&gt;RAII 的优势在于将对象的生命期管理与其他资源（锁、文件、网络连接等等）的管理整合，然后通过 smart pointers 一并解决了，这是 C++ 独一无二的优势。&lt;/p&gt;

&lt;p&gt;如果写递归下降的 parser，那么内部用异常来报错似乎是合理的，对外返回一个 error code 即可。&lt;/p&gt;
&lt;/blockquote&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;总之，呵呵～～&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>cpp primer 第四章笔记</title>
      <link>http://shamaoxiaogui.github.io/post/cpp_primer_note_4/</link>
      <pubDate>Tue, 19 Jul 2016 21:18:38 +0800</pubDate>
      
      <guid>http://shamaoxiaogui.github.io/post/cpp_primer_note_4/</guid>
      <description>&lt;p&gt;第四章主要是表达式相关的内容：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;除了&lt;code&gt;&amp;amp;&amp;amp; || ?: ,&lt;/code&gt;四种操作符外，其他操作符都没有定义运算顺序（重要）&lt;/li&gt;

&lt;li&gt;&lt;p&gt;sizeof是一种运算符，它不会对表达式进行求值，c++11允许用作用域运算符(::)来获取成员大小而不必提供一个实体（前提是，该成员是public的，活着调用方法是static的），对数组返回数组大小而不是指针大小，对vector和string这种返回其固定部分大小。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;string&amp;gt;
class testc{
public:
    char pwc;
    void update(){}
private:
    char wc;
};
int main(){
    int a=44;
    int ar[5];
    std::string str(&amp;quot;heheda!&amp;quot;);
    std::cout&amp;lt;&amp;lt;&amp;quot;int : &amp;quot;&amp;lt;&amp;lt;sizeof(a)&amp;lt;&amp;lt;&amp;quot; &amp;quot;&amp;lt;&amp;lt;sizeof(int)&amp;lt;&amp;lt;std::endl;
    std::cout&amp;lt;&amp;lt;&amp;quot;int [5]: &amp;quot;&amp;lt;&amp;lt;sizeof(ar)&amp;lt;&amp;lt;&amp;quot; &amp;quot;&amp;lt;&amp;lt;sizeof(int [5])&amp;lt;&amp;lt;std::endl;
    std::cout&amp;lt;&amp;lt;&amp;quot;string :&amp;quot;&amp;lt;&amp;lt;sizeof(str)&amp;lt;&amp;lt;&amp;quot; &amp;quot;&amp;lt;&amp;lt;sizeof(std::string)&amp;lt;&amp;lt;std::endl;
    std::cout&amp;lt;&amp;lt;&amp;quot;class member(char): &amp;quot;&amp;lt;&amp;lt;sizeof(testc::pwc)&amp;lt;&amp;lt;std::endl;
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ ./sizeoftest.out
int : 4 4
int [5]: 20 20
string :24 24
class member(char): 1
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;逗号运算符先算左边再算右边，最后返回右边，若右边结果为左值则返回的也是左值&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;大多数情况下数组退化为指针，有四种例外：decltype、取址运算符（&amp;amp;），sizeof，typeid：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;iostream&amp;gt;
int main(){
    int a[4];
    std::cout&amp;lt;&amp;lt;&amp;quot;int size: &amp;quot;&amp;lt;&amp;lt;sizeof(int)&amp;lt;&amp;lt;std::endl;
    std::cout&amp;lt;&amp;lt;&amp;quot;arr size: &amp;quot;&amp;lt;&amp;lt;sizeof(a)&amp;lt;&amp;lt;std::endl;
    std::cout&amp;lt;&amp;lt;&amp;quot;a[0] addr: &amp;quot;&amp;lt;&amp;lt;&amp;amp;a[0]&amp;lt;&amp;lt;std::endl;
    std::cout&amp;lt;&amp;lt;&amp;quot;a addr: &amp;quot;&amp;lt;&amp;lt;a&amp;lt;&amp;lt;std::endl;
    std::cout&amp;lt;&amp;lt;&amp;quot;&amp;amp;a :&amp;quot;&amp;lt;&amp;lt;&amp;amp;a&amp;lt;&amp;lt;std::endl;
    std::cout&amp;lt;&amp;lt;&amp;quot;&amp;amp;a[0]+1: &amp;quot;&amp;lt;&amp;lt;&amp;amp;a[0]+1&amp;lt;&amp;lt;std::endl;
    std::cout&amp;lt;&amp;lt;&amp;quot;a+1: &amp;quot;&amp;lt;&amp;lt;a+1&amp;lt;&amp;lt;std::endl;
    std::cout&amp;lt;&amp;lt;&amp;quot;&amp;amp;a+1: &amp;quot;&amp;lt;&amp;lt;&amp;amp;a+1&amp;lt;&amp;lt;std::endl;
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ ./arrayaddr.out
int size: 4
arr size: 16
a[0] addr: 0x7fff566947e0
a addr: 0x7fff566947e0
&amp;amp;a :0x7fff566947e0
&amp;amp;a[0]+1: 0x7fff566947e4
a+1: 0x7fff566947e4
&amp;amp;a+1: 0x7fff566947f0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以发现当采取&lt;code&gt;&amp;amp;a+1&lt;/code&gt;这种形式时，与数组首地址相比，并不是单纯加4，而是加4*4，故而大胆推测，&lt;code&gt;&amp;amp;a&lt;/code&gt;的类型为&lt;code&gt;int [4]&lt;/code&gt;（类似二维数组中的一维元素）&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;指针的转换规则：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;0和nullptr可以转换成任意指针（空指针）&lt;/li&gt;
&lt;li&gt;任意非常量指针可以转换成&lt;code&gt;void*&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;任意指针可以转换成&lt;code&gt;const void*&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;显示转换：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;static_cast&lt;/code&gt;就相当于c的强制类型转换&lt;/li&gt;
&lt;li&gt;&lt;code&gt;const_cast&lt;/code&gt;去除底层const属性，但是对转换后的对象（一般是指针，对其指向的对象）写操作是未定义的，而且不能改变变量类型&lt;/li&gt;
&lt;li&gt;&lt;code&gt;reinterpret_cast&lt;/code&gt;最危险的转换，相当于对同一个内存的地址做不同意义的解释（比如把一个int＊解释为一个char＊），依赖于机器&lt;/li&gt;
&lt;li&gt;&lt;code&gt;dynamic_cast&lt;/code&gt;将指向子类的父类型的指针转化为子类型，这个功能也可以由&lt;code&gt;static_cast&lt;/code&gt;来实现，但是dy会在运行时检查父子类关系，而static只会在编译时检查&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>cpp primer 第三章笔记</title>
      <link>http://shamaoxiaogui.github.io/post/cpp_primer_note_3/</link>
      <pubDate>Tue, 19 Jul 2016 17:05:39 +0800</pubDate>
      
      <guid>http://shamaoxiaogui.github.io/post/cpp_primer_note_3/</guid>
      <description>&lt;p&gt;第三章主要讲vector和string&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;string到底是不是以\0结尾的？c++11中规定&lt;strong&gt;&lt;em&gt;是&lt;/em&gt;&lt;/strong&gt;。但是不要依赖这个特性，乖乖的用size()；但是getline的时候换行符确实丢掉了&lt;/li&gt;

&lt;li&gt;&lt;p&gt;auto for循环，注意效率，有些时候auto for效率更高（迭代器最慢～～）&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;chrono&amp;gt;
#include &amp;lt;string&amp;gt;
int main(){
    int n;
    char ch;
    std::cout&amp;lt;&amp;lt;&amp;quot;input n: &amp;quot;;
    std::cin&amp;gt;&amp;gt;n;
    std::cout&amp;lt;&amp;lt;std::endl;
    std::string str(n,&#39;c&#39;);
    std::chrono::high_resolution_clock::time_point t1,t2;
    t1=std::chrono::high_resolution_clock::now();
    for(int i=0;i&amp;lt;n;++i){
        ch=str[i];
    }
    t2=std::chrono::high_resolution_clock::now();
    std::cout&amp;lt;&amp;lt;&amp;quot;for: &amp;quot;&amp;lt;&amp;lt;std::chrono::duration_cast&amp;lt;std::chrono::microseconds&amp;gt;(t2-t1).count()&amp;lt;&amp;lt;&amp;quot; microseconds&amp;quot;&amp;lt;&amp;lt;std::endl;
    t1=std::chrono::high_resolution_clock::now();
    for(auto t:str){
        ch=t;
    }
    t2=std::chrono::high_resolution_clock::now();
    std::cout&amp;lt;&amp;lt;&amp;quot;auto for: &amp;quot;&amp;lt;&amp;lt;std::chrono::duration_cast&amp;lt;std::chrono::microseconds&amp;gt;(t2-t1).count()&amp;lt;&amp;lt;&amp;quot; microseconds&amp;quot;&amp;lt;&amp;lt;std::endl;
    t1=std::chrono::high_resolution_clock::now();
    for(auto &amp;amp;t:str){
        ch=t;
    }
    t2=std::chrono::high_resolution_clock::now();
    std::cout&amp;lt;&amp;lt;&amp;quot;auto&amp;amp; for: &amp;quot;&amp;lt;&amp;lt;std::chrono::duration_cast&amp;lt;std::chrono::microseconds&amp;gt;(t2-t1).count()&amp;lt;&amp;lt;&amp;quot; microseconds&amp;quot;&amp;lt;&amp;lt;std::endl;
    t1=std::chrono::high_resolution_clock::now();
    for(const auto &amp;amp;t:str){
        ch=t;
    }
    t2=std::chrono::high_resolution_clock::now();
    std::cout&amp;lt;&amp;lt;&amp;quot;const auto&amp;amp; for: &amp;quot;&amp;lt;&amp;lt;std::chrono::duration_cast&amp;lt;std::chrono::microseconds&amp;gt;(t2-t1).count()&amp;lt;&amp;lt;&amp;quot; microseconds&amp;quot;&amp;lt;&amp;lt;std::endl;
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ ./fortest.out
input n: 1000000000

for: 9104902 microseconds
auto for: 5651329 microseconds
auto&amp;amp; for: 5445633 microseconds
const auto&amp;amp; for: 5508764 microseconds
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;但是切记范围for不能改变循环序列的大小！！！&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;string的c_str()返回的char*字符串有可能不保证一直有效！！！&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>cpp primer 第二章笔记</title>
      <link>http://shamaoxiaogui.github.io/post/cpp_primer_note_2/</link>
      <pubDate>Tue, 19 Jul 2016 15:16:37 +0800</pubDate>
      
      <guid>http://shamaoxiaogui.github.io/post/cpp_primer_note_2/</guid>
      <description>

&lt;p&gt;第二章主要讲的是基本类型，需要注意的有：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;同一个表达式混用&lt;strong&gt;&lt;em&gt;有符号&lt;/em&gt;&lt;/strong&gt;和&lt;strong&gt;&lt;em&gt;无符号&lt;/em&gt;&lt;/strong&gt;数，会自动转换成&lt;strong&gt;&lt;em&gt;无符号&lt;/em&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;字面值前缀指定字符编码，后缀指定变量大小或种类&lt;/li&gt;

&lt;li&gt;&lt;p&gt;字符串字面值不可修改（因为放在一个只读段中）&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;iostream&amp;gt;
int main(){
    char *str=&amp;quot;heheda!&amp;quot;;
    std::cout&amp;lt;&amp;lt;&amp;quot;before m: &amp;quot;&amp;lt;&amp;lt;str&amp;lt;&amp;lt;std::endl;
    str[3]=&#39;a&#39;;
    std::cout&amp;lt;&amp;lt;&amp;quot;after m: &amp;quot;&amp;lt;&amp;lt;str&amp;lt;&amp;lt;std::endl;
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ ./cstr.out
before m: heheda!
[2]    37400 bus error  ./cstr.out
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;c++11&lt;/code&gt;提供了一种新的*列表初始化*，但是效率么。。。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;string&amp;gt;
#include &amp;lt;vector&amp;gt;
class tc{
public:
    tc(){std::cout&amp;lt;&amp;lt;&amp;quot;ct a class! &amp;quot;&amp;lt;&amp;lt;std::endl;}
    tc(const tc &amp;amp;t){std::cout&amp;lt;&amp;lt;&amp;quot;copy a class!&amp;quot;&amp;lt;&amp;lt;std::endl;}
    tc&amp;amp; operator=(tc &amp;amp;t){std::cout&amp;lt;&amp;lt;&amp;quot;= a class!&amp;quot;&amp;lt;&amp;lt;std::endl; return *this;}
};
int main(){
    tc t1;
    std::cout&amp;lt;&amp;lt;&amp;quot;===============&amp;quot;&amp;lt;&amp;lt;std::endl;
    tc t2(t1);
    std::cout&amp;lt;&amp;lt;&amp;quot;===============&amp;quot;&amp;lt;&amp;lt;std::endl;
    tc t3=t1;
    std::cout&amp;lt;&amp;lt;&amp;quot;===============&amp;quot;&amp;lt;&amp;lt;std::endl;
    tc t4{t1};
    std::cout&amp;lt;&amp;lt;&amp;quot;===============&amp;quot;&amp;lt;&amp;lt;std::endl;
    tc t5={t1};
    std::cout&amp;lt;&amp;lt;&amp;quot;===============&amp;quot;&amp;lt;&amp;lt;std::endl;
    std::vector&amp;lt;tc&amp;gt; tcv{t1,t2,t3};
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ ./initlist.out
ct a class!
===============
copy a class!
===============
copy a class!
===============
copy a class!
===============
copy a class!
===============
copy a class!
copy a class!
copy a class!
copy a class!
copy a class!
copy a class!
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;所以在用容器时不要随便用初始化列表，详细见&lt;a href=&#34;https://segmentfault.com/a/1190000002484690&#34;&gt;这里&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;const相关&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;const变量只能初始化不能赋值（哈士奇都知道）&lt;/li&gt;
&lt;li&gt;不加extern的const变量只能在本文件访问（所以说加了呢）&lt;/li&gt;
&lt;li&gt;const左值引用可以绑定：const变量，非const变量，常量（字面量，这也是std::string的设计，只能将字符串传给const std::string &amp;amp;，而不能传给std::string &amp;amp;），无论如何，常量左值引用意味着不能通过这个引用去修改变量&lt;/li&gt;
&lt;li&gt;顶层const指指针本身的值是常量，底层const则是指针指向的值是常量，故而在函数传参或者复制指针时，顶层const忽略（反正就算你是常量我也只是复制你，后面无论怎么操作也不会修改你），底层const则不能忽略（因为有可能通过复制的指针修改数据）&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;constexpr常量表达式，由编译器帮忙检查；using的别名声明功能（类似typedef—）&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;单纯的auto的推断效果：忽略顶层const，然后把表达式的值算出来是啥类型auto就是啥类型。底层const保留。加const的auto推断出来才是顶层const的，auto &amp;amp;推断出来才是引用&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;decltype基本保留变量的所有属性，尤其是当变量为引用时推断出来的结果也是引用。当其表达式是解引用操作时，结果必为引用，而其跟双括号表达式（加了括号的变量），结果必为引用&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;注意类内初始值的初始化顺序：类内初始值－》构造函数初始化列表－》构造函数体&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;2016-07-21添加&#34;&gt;2016-07-21添加&lt;/h2&gt;

&lt;p&gt;我又回过头来看了一下，关于initializer_list，之前的示例代码中使用的是左值，所以拷贝了两次，但是当我给类添加移动构造函数并使用std::move将其转换为右值后：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;std::cout&amp;lt;&amp;lt;&amp;quot;===============&amp;quot;&amp;lt;&amp;lt;std::endl;
std::vector&amp;lt;tc&amp;gt; tcv3{std::move(t1),std::move(t2),std::move(t3)};
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;===============
move a class!
move a class!
move a class!
copy a class!
copy a class!
copy a class!
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;出现了这种结果。
似乎不太对，按道理来说initializer_list的设计应该是为了方便用临时量来构造一个集合（按我自己的理解），既然是临时量标准库应该提供转移语义，现在看来并没有。其它的情况我找到了stackoverflow上的一个&lt;a href=&#34;http://stackoverflow.com/questions/8193102/initializer-list-and-move-semantics&#34;&gt;讨论&lt;/a&gt;，显然想要手动从里面转移出临时量也不可以，怪怪的感觉&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>cpp primer 第一章笔记</title>
      <link>http://shamaoxiaogui.github.io/post/cpp_primer_note_1/</link>
      <pubDate>Tue, 19 Jul 2016 14:20:39 +0800</pubDate>
      
      <guid>http://shamaoxiaogui.github.io/post/cpp_primer_note_1/</guid>
      <description>&lt;p&gt;第一章只是一个引入，要注意的有：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;std::cin&lt;/code&gt;在读到EOF的情形&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;iostream&amp;gt;
int main(){
    int val;
    while(std::cin&amp;gt;&amp;gt;val){
        std::cout&amp;lt;&amp;lt;val&amp;lt;&amp;lt;&amp;quot; &amp;quot;;
    }
    std::cout&amp;lt;&amp;lt;std::endl;
    std::cout&amp;lt;&amp;lt;&amp;quot;after loop,val= &amp;quot;&amp;lt;&amp;lt;val&amp;lt;&amp;lt;std::endl;
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;测试发现最终结束时，输入C+D(EOF)与输入非数字，最终val的值是不一样的&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;
$ ./istest
1
1 $

after loop,val= 0

$ ./istest
1
1 ^D
    
after loop,val= 1

&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;std::cout,std::cerr,std::clog&lt;/code&gt;的区别&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;iostream&amp;gt;
int main(){
    std::cout&amp;lt;&amp;lt;&amp;quot;from cout&amp;quot;&amp;lt;&amp;lt;std::endl;
    std::clog&amp;lt;&amp;lt;&amp;quot;from clog&amp;quot;&amp;lt;&amp;lt;std::endl;
    std::cerr&amp;lt;&amp;lt;&amp;quot;from cerr&amp;quot;&amp;lt;&amp;lt;std::endl;
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;测试结果：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ ./istest &amp;amp;&amp;amp; echo &amp;quot;======&amp;quot; &amp;amp;&amp;amp; ./istest 2&amp;gt;hehe
from cout
from clog
from cerr
======
from cout
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;总结：
    - cout 标准输出
    - cerr 标准错误
    - clog 标准错误（貌似带缓冲，没验证）&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>搬家记录</title>
      <link>http://shamaoxiaogui.github.io/post/FirstPost/</link>
      <pubDate>Sun, 17 Jul 2016 13:09:40 +0800</pubDate>
      
      <guid>http://shamaoxiaogui.github.io/post/FirstPost/</guid>
      <description>&lt;p&gt;折腾了一上午，最后还是选择从hexo迁到hugo，记录一下～&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>